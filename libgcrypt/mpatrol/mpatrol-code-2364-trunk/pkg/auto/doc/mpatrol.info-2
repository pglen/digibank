This is mpatrol.info, produced by makeinfo version 4.13 from
mpatrol.texi.

INFO-DIR-SECTION Programming tools
START-INFO-DIR-ENTRY
* mpatrol: (mpatrol).           The mpatrol library.
END-INFO-DIR-ENTRY

   This file documents mpatrol, a library for controlling and tracing
dynamic memory allocations.

   Copyright (C) 1997-2008 Graeme S. Roy
<graemeroy@users.sourceforge.net>

   This is edition 2.17 of the mpatrol manual for version 1.5.1, 19th
December, 2008.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

   All product names mentioned in the documentation and source code for
this library are the trademarks of their respective owners.


File: mpatrol.info,  Node: Example 1,  Next: Example 2,  Up: Examples

16.1 Getting started
====================

The first example we'll look at is when the argument in a call to
`free()' doesn't match the return value from `malloc()', even though
the intention is to free the memory that was allocated by `malloc()'.
This example is in `tests/fail/test1.c' and causes many existing
`malloc()' implementations to crash.

   Along the way, I'll try to describe as many features of the mpatrol
library as possible, and illustrate them with examples.  Note that the
output from your version of the library is likely to vary slightly from
that shown in the examples, especially on non-UNIX systems.

     23  /*
     24   * Allocates a block of 16 bytes and then attempts to free the
     25   * memory returned at an offset of 1 byte into the block.
     26   */


     29  #include "mpatrol.h"


     32  int main(void)
     33  {
     34      char *p;

     36      if (p = (char *) malloc(16))
     37          free(p + 1);
     38      return EXIT_SUCCESS;
     39  }

   Note that I've removed the copyright message from the start of the
file and added line numbers so that the tracing below makes more sense.

   After compiling and linking the above program with the mpatrol
library, the `MPATROL_OPTIONS' environment variable should be set to be
`LOGALL' and the program should be executed, generating the following
output in `mpatrol.log'.

     @(#) mpatrol 1.5.1 (08/12/16)
     Copyright (C) 1997-2008 Graeme S. Roy

     This is free software, and you are welcome to redistribute it under
     certain conditions; see the GNU Lesser General Public License for
     details.

     For the latest mpatrol release and documentation,
     visit http://sourceforge.net/projects/mpatrol.

     operating system:       UNIX
     system variant:         Linux
     processor architecture: Intel 80x86
     processor word size:    32-bit
     object file format:     BFD
     dynamic linker type:    SVR4

     Log file generated on Tue Dec 16 10:10:12 2008

     read 310 symbols from /usr/lib/libmpatrol.so.1.5
     read 647 symbols from /usr/lib/libbfd-2.9.5.0.22.so
     read 2634 symbols from /lib/libc.so.6
     read 1142 symbols from /usr/lib/libstdc++-libc6.1-1.so.2
     read 695 symbols from /lib/libm.so.6
     read 178 symbols from /lib/ld-linux.so.2
     read 158 symbols from ./test1

     ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test1.c|36]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     returns 0x080620E8

     FREE: free (0x080620E9) [main|test1.c|37]
             0x08049457 main+71
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     ERROR: [MISMAT]: free: 0x080620E9 does not match allocation of 0x080620E8
         0x080620E8 (16 bytes) {malloc:52:0} [main|test1.c|36]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     system page size:  4096 bytes
     default alignment: 4 bytes
     overflow size:     0 bytes
     overflow byte:     0xAA
     allocation byte:   0xFF
     free byte:         0x55
     allocation stop:   0
     reallocation stop: 0
     free stop:         0
     unfreed abort:     0
     small boundary:    32 bytes
     medium boundary:   256 bytes
     large boundary:    2048 bytes
     lower check range: 0
     upper check range: 0
     check frequency:   1
     failure frequency: 0
     failure seed:      972951591
     prologue function: <unset>
     epilogue function: <unset>
     handler function:  <unset>
     log file:          mpatrol.log
     profiling file:    mpatrol.out
     tracing file:      mpatrol.trace
     program filename:  ./test1
     symbols read:      5764
     autosave count:    0
     freed queue size:  0
     allocation count:  52
     allocation peak:   20 (427512 bytes)
     allocation limit:  0 bytes
     allocated blocks:  7 (1528 bytes)
     marked blocks:     0 (0 bytes)
     freed blocks:      0 (0 bytes)
     free blocks:       4 (432648 bytes)
     internal blocks:   33 (540672 bytes)
     total heap usage:  974848 bytes
     total compared:    0 bytes
     total located:     2 bytes
     total copied:      32176 bytes
     total set:         582856 bytes
     total warnings:    0
     total errors:      1

   Ignoring the copyright blurb and target environment information at
the top of the file, let's first take a look at the initial log message
from the library.  I've annotated each of the items with a number that
corresponds to the descriptions below.

      (1)    (2)   (3)    (4)       (5)     (6)    (7)  (8)
       |      |     |      |         |       |      |    |
       V      V     V      V         V       V      V    V
     ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test1.c|36]
      (9) -> 0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33 <- (10)

     returns 0x080620E8 <- (11)

  1. Allocation type.  This generalises the type of dynamic memory
     operation that is being performed, and can be one of `ALLOC',
     `REALLOC' or `FREE'.  This should make looking for all
     allocations, reallocations or frees in the log file a lot easier.
     Alternatively, if a memory operation function was called then this
     can also be one of `MEMSET', `MEMCOPY', `MEMFIND' or `MEMCMP'.

  2. Allocation function.  This is the name of the function that has
     been called to allocate the memory, in this case `malloc'.

  3. Allocation index.  This is incremented every time a new memory
     allocation is requested, and persists even if the memory
     allocation is resized with `realloc()' and its related functions,
     so can be useful to keep track of a memory allocation, even if its
     start address changes.  The mpatrol library may use up the first
     few allocation indices when it gets initialised.

  4. Size of requested allocation.

  5. Alignment for requested allocation.  This is normally the default
     system alignment for general-purpose memory allocations, but may
     be different depending on the type of function that is used to
     allocate the memory.

   The following information contains source file details of where the
call to `malloc()' came from, but is only available if the source file
containing the call to `malloc()' included `mpatrol.h'; otherwise the
fields will all be `-'(1).  Because of the convoluted way this
information is obtained for the C++ operators, you may encounter some
problems in existing C++ programs when making direct calls to `operator
new' for example.  However, if you want to disable the redefinition of
the C++ operators in `mpatrol.h' you can define the preprocessor macro
`MP_NOCPLUSPLUS' before the inclusion of that file.  Alternatively, you
may wish to define the `MP_NONEWDELETE' preprocessor macro in order to
use `MP_NEW', `MP_NEW_NOTHROW' and `MP_DELETE' instead of `new' and
`delete'.  That way you can combine calls to mpatrol's operators and
the standard operators.  Just make sure you don't mix them!

   If you are running on a system on which mpatrol supports full
symbolic stack tracebacks the following information may still be useful
if the source files were compiled with optimisation turned on.  This is
because the calling function may have been inlined, in which case you
will only see the name of the function into which the calling function
was expanded in the stack traceback.

  6. Function where call to `malloc()' took place.  This information is
     only available if the source file containing the call to
     `malloc()' was compiled with `gcc' or `g++'.

  7. Filename in which call to `malloc()' took place.

  8. Line number at which call to `malloc()' took place.

   The following information contains function call stack details of
where the call to `malloc()' came from, but is only available if the
mpatrol library has been built on a platform that supports this.  The
top-most entry should be the function which called `malloc()' and the
bottom-most entry should be the entry-point for the process.

  9. Address of function call.  This is normally the address of the
     machine instruction immediately after the function call
     instruction, also known as the return address.

 10. Function where call took place.  This information is only
     available if the mpatrol library has been built on a platform that
     supports reading symbol table information from executable files,
     and then only if there is an entry in the symbol table
     corresponding to the return address.  C++ function names may still
     be in their mangled form, but this can be easily rectified by
     processing the log file with a C++ name demangler.  The number
     after the plus sign is the offset in bytes from the beginning of
     the function.

   The following information is only available when the allocation type
is `ALLOC' or `REALLOC' since it makes no sense when applied to `FREE'.

 11. The address of the new memory block that has been allocated by
     `malloc()'.

   As you can see, there is quite a lot of information that can be
displayed from a simple call to `malloc()', and hopefully this
information has been presented in a clear and concise format in the log
file.

   The next entries in the log file correspond to the call to `free()',
which attempts to free the memory allocated by `malloc()', but supplies
the wrong address.

   The first four lines should be self-explanatory as they are very
similar to those described above for `malloc()'.  However, the next
lines signal that a terminal error has occurred in the program, so I've
annotated them as before.

     FREE: free (0x080620E9) [main|test1.c|37]
             0x08049457 main+71
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

      (1)     (2)      (3)
       |       |        |
       V       V        V
     ERROR: [MISMAT]: free: 0x080620E9 does not match allocation of 0x080620E8
            (4)        (5)       (6)  (7)(8)  (9)    (10) (11)
             |          |         |    |  |    |      |    |
             V          V         V    V  V    V      V    V
         0x080620E8 (16 bytes) {malloc:52:0} [main|test1.c|36]
     (12) -> 0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

  1. Error severity.  The mpatrol library has two different severities
     of error: `WARNING' and `ERROR'.  The first is always recoverable,
     and serves only to indicate that something is not quite right, and
     so may be useful in determining where something started to go
     wrong.  The second may or may not be recoverable, and the library
     terminates the program if it is fatal, displaying any relevant
     information as it does this.

  2. Error abbreviation code.  This is a code that is different for
     each type of error that is detected by the mpatrol library.  Some
     warnings and errors that are not directly related to the program
     being run will not contain this field.  See the appendix on
     diagnostic messages (*note Diagnostic messages::) for a complete
     list of all possible error abbreviation codes and their
     descriptions.

  3. Allocation function.  This is the name of the function used to
     allocate, reallocate or free memory where the error was detected.
     This may be omitted if an error is detected elsewhere in the
     library.

   The following information is related to the information that the
library has stored about the relevant memory allocation.  This
information is always displayed in this format when details of
individual memory allocations are required.  If any information is
missing then it simply means that the library was not able to determine
it when the memory block was first allocated.

  4. Address of memory allocation.

  5. Size of memory allocation.

  6. Allocation function.  This is the name of the function that was
     called to allocate the memory block, in this case `malloc'.  If
     the memory allocation has been resized then this will be either
     `realloc', `reallocf', `recalloc', `expand' or `xrealloc'.

  7. Allocation index.

  8. Reallocation index.  This is used to count the number of times a
     memory allocation has been resized with `realloc()' and its
     related functions.

  9. Function where original call to `malloc()' took place.  If the
     memory allocation has been resized then this will be the name of
     the function which last called `realloc()' and its related
     functions.

 10. Filename in which original call to `malloc()' took place.  If the
     memory allocation has been resized then this will be the filename
     in which the last call to `realloc()' and its related functions
     took place.

 11. Line number at which original call to `malloc()' took place.  If
     the memory allocation has been resized then this will be the line
     number at which the last call to `realloc()' and its related
     functions took place.

 12. Function call stack of original memory allocation.  If the memory
     allocation has been resized then this will be the call stack of
     the last call to `realloc()' and related functions.

   So, the mpatrol library detected the error in the above program and
terminated it.  When the library terminates it always displays a
summary of various memory allocation statistics and settings that were
used during the execution of the program.

   The various settings and statistics displayed by the library for the
above example have been numbered and their descriptions appear below.

      1  system page size:  4096 bytes
      2  default alignment: 4 bytes
      3  overflow size:     0 bytes
      4  overflow byte:     0xAA
      5  allocation byte:   0xFF
      6  free byte:         0x55
      7  allocation stop:   0
      8  reallocation stop: 0
      9  free stop:         0
     10  unfreed abort:     0
     11  small boundary:    32 bytes
     12  medium boundary:   256 bytes
     13  large boundary:    2048 bytes
     14  lower check range: 0
     15  upper check range: 0
     16  check frequency:   1
     17  failure frequency: 0
     18  failure seed:      972951591
     19  prologue function: <unset>
     20  epilogue function: <unset>
     21  handler function:  <unset>
     22  log file:          mpatrol.log
     23  profiling file:    mpatrol.out
     24  tracing file:      mpatrol.trace
     25  program filename:  ./test1
     26  symbols read:      5764
     27  autosave count:    0
     28  freed queue size:  0
     29  allocation count:  52
     30  allocation peak:   20 (427512 bytes)
     31  allocation limit:  0 bytes
     32  allocated blocks:  7 (1528 bytes)
     33  marked blocks:     0 (0 bytes)
     34  freed blocks:      0 (0 bytes)
     35  free blocks:       4 (432648 bytes)
     36  internal blocks:   33 (540672 bytes)
     37  total heap usage:  974848 bytes
     38  total compared:    0 bytes
     39  total located:     2 bytes
     40  total copied:      32176 bytes
     41  total set:         582856 bytes
     42  total warnings:    0
     43  total errors:      1

  1. System page size.  This value is used on some platforms when
     allocating and protecting system memory.

  2. Default alignment.  This value is the minimum alignment required
     for general purpose memory allocations, and is usually the
     alignment required by the most restrictive datatype on a given
     system.  It is used when allocating memory that has no specified
     alignment.  It can be changed at run-time using the `DEFALIGN'
     option, but setting this value too small may cause the program to
     crash due to bus errors which are caused by reading from or
     writing to misaligned data.

  3. Overflow size.  This value is the size used by one overflow
     buffer.  If this is non-zero then every memory allocation will
     have two overflow buffers; one on either side.  These buffers are
     used by the library to detect if the program has written too many
     bytes to a memory allocation, thus overflowing into one of the
     buffers, but these extra checks can slow down execution speed.  It
     can be changed at run-time using the `OFLOWSIZE' option.

  4. Overflow byte.

  5. Allocation byte.

  6. Free byte.  These values are used by the library to pre-fill
     blocks of memory for checking purposes.  The overflow byte is used
     to fill overflow buffers, the allocation byte is used to fill
     newly-allocated memory (except from `calloc()' or `recalloc()'),
     and the free byte is used to fill free blocks or freed memory
     allocations.  These can be changed at run-time using the
     `OFLOWBYTE', `ALLOCBYTE' and `FREEBYTE' options.

  7. Allocation stop.

  8. Reallocation stop.

  9. Free stop.  These values are used by the library to halt the
     program when run inside a debugger whenever a specified allocation
     index is allocated, reallocated or freed.  These can be changed at
     run-time using the `ALLOCSTOP', `REALLOCSTOP' and `FREESTOP'
     options.

 10. Unfreed abort.  This value is used when the program terminates and
     is used by the library to check if there are more than a given
     number of unfreed memory allocations.  If there are then the
     library will cause the program to abort with an error.  It can be
     changed at run-time using the `UNFREEDABORT' option.

 11. Small boundary.

 12. Medium boundary.

 13. Large boundary.  These values are used in memory allocation
     profiling and specify the boundaries in bytes between small,
     medium, large and extra large allocations.  These can be changed
     at run-time using the `SMALLBOUND', `MEDIUMBOUND' and `LARGEBOUND'
     options.

 14. Lower check range.

 15. Upper check range.

 16. Check frequency.  These values specify the range of allocation
     indices through which the library will physically check every area
     of free memory and every overflow buffer for errors, along with
     the frequency at which to make the checks.  A dash specifies that
     either the lower or upper range is infinite, but if they are both
     zero then no such checking will ever be performed, thus speeding
     up execution speed dramatically.  The check frequency indicates the
     number of memory allocation events that must occur in between
     checking the heap.  The library defaults to performing no such
     checks.  This can be changed at run-time using the `CHECK' option.

 17. Failure frequency.

 18. Failure seed.  These values are used to specify if random memory
     allocation failures should occur during program execution, for the
     purposes of stress testing a program.  If the failure frequency is
     zero then no random failures will occur, but if it is greater than
     zero then the higher the number, the less frequent the failures.
     The failure seed is used internally by the mpatrol library when
     generating random numbers.  If it is zero then the seed will be set
     randomly, but if it is greater than zero then it will be used to
     generate a predictable sequence of random numbers; i.e. two runs
     of the same program with the same failure frequencies and the same
     failure seeds will generate exactly the same sequence of failures.

 19. Prologue function.  

 20. Epilogue function.  

 21. Handler function.  These values contain addresses or names of
     functions that have been installed as callback functions for the
     library.  These functions, if set, will be called from the library
     at appropriate times during program execution in order to handle
     specific events.  These can be changed at compile-time using the
     `__mp_prologue()', `__mp_epilogue()' and `__mp_nomemory()'
     functions.

 22. Log file.  Simply contains the name of the file where all mpatrol
     library diagnostics go to.  It can be changed at run-time using
     the `LOGFILE' option.

 23. Profiling file.  Contains the name of the file where all of the
     mpatrol library memory allocation profiling information goes when
     the `PROF' option is used.  It can be changed at run-time using
     the `PROFFILE' option.

 24. Tracing file.  Contains the name of the file where all of the
     mpatrol library memory allocation tracing information goes when
     the `TRACE' option is used.  It can be changed at run-time using
     the `TRACEFILE' option.

 25. Program filename.  Contains the full pathname to the program's
     executable file.  This is used by the mpatrol library to read the
     symbol table in order to provide symbolic information in function
     call stacks.  It can be changed at run-time using the `PROGFILE'
     option.

 26. Symbols read.  This value contains the total number of symbols
     read from a program's executable file and/or the dynamic linker,
     if applicable.

 27. Autosave count.  This value contains the frequency at which the
     mpatrol library should periodically write the profiling data to
     the profiling output file.  When the total number of profiled
     memory allocations and deallocations is a multiple of this number
     then the current profiling information will be written to the
     profiling output file.  It can be changed at run-time using the
     `AUTOSAVE' option.

 28. Freed queue size.  This value contains the maximum number of freed
     memory allocations that will be stored in the freed queue if the
     `NOFREE' option is used.  Once the freed queue becomes full then
     the oldest freed allocation in the queue will be returned to the
     free memory pool for reuse every time an existing memory
     allocation is freed.  If this value is zero then the freed queue
     will never contain any freed allocations.  It can be changed at
     run-time using the `NOFREE' option.

 29. Allocation count.  This value contains the total number of memory
     allocations that were created by the mpatrol library.  This value
     may be more than expected if the mpatrol library makes any memory
     allocations during initialisation.

 30. Allocation peak.  This value contains the peak memory usage set by
     the program when running; the peak number of memory allocations,
     and also the peak number of bytes allocated in parentheses (the
     two numbers may peak at different times throughout the lifetime of
     the program).  This value may be more than expected if the mpatrol
     library makes any memory allocations during initialisation.

 31. Allocation limit.  This value is used to limit the amount of
     memory that can be allocated by a program, which can be useful for
     stress-testing in simulated low memory conditions.  It can be
     changed at run-time using the `LIMIT' option.

 32. Allocated blocks.

 33. Marked blocks.

 34. Freed blocks.

 35. Free blocks.  These values contain the total number of allocated,
     marked, freed and free blocks at the time the summary was
     produced.  A marked block is an allocated block that the user has
     instructed (via the `__mp_setmark()' function) the mpatrol library
     should remain allocated for the rest of the lifetime of the
     program and should never be freed or counted as a memory leak.  A
     freed block is an allocated block that has been freed but has not
     been returned to the free memory list for later allocation.  These
     values may be different from those expected if the mpatrol library
     makes any memory allocations during initialisation.  In this
     example a large amount of memory is used by the system object file
     access library which is used for reading the symbols from the
     program's executable file and any shared libraries that it
     requires.

 36. Internal blocks.  This value contains the total number of memory
     blocks (of varying sizes) that have been allocated from the system
     for the mpatrol library to use internally.  These memory blocks
     will be write-protected on systems that support memory protection
     in order to prevent the program from corrupting the library's data
     structures.  This can be overridden at run-time using the
     `NOPROTECT' option in order to speed up program execution slightly.

 37. Total heap usage.  This value contains the total amount of system
     heap memory that has been allocated by the mpatrol library.

 38. Total compared.

 39. Total located.

 40. Total copied.

 41. Total set.  These values contain the total number of bytes that
     have been tracked by the mpatrol library in byte comparison
     operations (such as `memcmp()'), byte location operations (such as
     `memchr()', byte copy operations (such as `memcpy()') and byte set
     operations (such as `memset()') respectively.  They do not take
     into account any other such operations that occur outwith these
     functions, such as loading and storing from machine instructions.

 42. Total warnings.

 43. Total errors.  The library keeps a count of the total number of
     warnings and errors it has displayed so that you can quickly work
     out this information at program termination.

   ---------- Footnotes ----------

   (1) This information may also be filled in if the `USEDEBUG' option
or the `mpsym' command is used and supported, and if debugging
information about the call to `malloc()' is available.


File: mpatrol.info,  Node: Example 2,  Next: Example 3,  Prev: Example 1,  Up: Examples

16.2 Detecting incorrect reuse of freed memory
==============================================

The next example uses `tests/fail/test2.c' to illustrate how the mpatrol
library can detect whereabouts on the heap an address belongs.

     23  /*
     24   * Allocates a block of 16 bytes and then immediately frees it.  An
     25   * attempt is then made to double the size of the original block.
     26   */


     29  #include "mpatrol.h"


     32  int main(void)
     33  {
     34      char *p;

     36      if (p = (char *) malloc(16))
     37      {
     38          free(p);
     39          p = (char *) realloc(p, 32);
     40      }
     41      return EXIT_SUCCESS;
     42  }

   The relevant excerpts from `mpatrol.log' appear below.  The format
of the log messages should be familiar to you now.

     ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test2.c|36]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     returns 0x080620E8

     FREE: free (0x080620E8) [main|test2.c|38]
             0x08049456 main+70
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

         0x080620E8 (16 bytes) {malloc:52:0} [main|test2.c|36]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     REALLOC: realloc (0x080620E8, 32 bytes, 4 bytes) [main|test2.c|39]
             0x08049476 main+102
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     ERROR: [NOTALL]: realloc: 0x080620E8 has not been allocated

     returns 0x00000000

   The mpatrol library stores all of its information about allocated
and free memory in tree structures so that it can quickly determine if
an address belongs to allocated or free memory, or if it even exists in
the heap that is managed by mpatrol.  The above example should
illustrate this since after the allocation had been freed, the library
recognised this and reported an error.  It was possible for the program
to continue execution even after that error since mpatrol could recover
from it and return `NULL'.

   It is possible for mpatrol to give even more useful diagnostics in
the above situation by using the `NOFREE' option.  This prevents the
library from returning any freed allocations to the free memory pool,
by preserving any information about them and marking them as freed.  If
you add the `NOFREE=1' option to the `MPATROL_OPTIONS' environment
variable you should see the following entries in `mpatrol.log' instead.

     ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test2.c|36]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     returns 0x08062F54

     FREE: free (0x08062F54) [main|test2.c|38]
             0x08049456 main+70
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

         0x08062F54 (16 bytes) {malloc:52:0} [main|test2.c|36]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     REALLOC: realloc (0x08062F54, 32 bytes, 4 bytes) [main|test2.c|39]
             0x08049476 main+102
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     ERROR: [PRVFRD]: realloc: 0x08062F54 was freed with free
         0x08062F54 (16 bytes) {free:52:0} [main|test2.c|38]
             0x08049456 main+70
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

     returns 0x00000000

   Note the extra information reported by `realloc()' since the library
knows all of the details about the freed memory allocation and when it
was freed.

   The `NOFREE' option can potentially use up much more system memory
than normal if it is given a large numerical argument since it
effectively instructs the mpatrol library to allocate new memory for
every single memory allocation or reallocation.  It can also slow down
program execution when overflow buffers are used, since with each new
memory allocation the library needs to check more and more overflow
buffers every time it is called.  However, with a low numerical
argument it can be quite useful for problems such as this one.  The
test in `tests/fail/test3.c' has a similar situation.

   The numerical argument specified with the `NOFREE' option indicates
the number of recently-freed memory allocations that are to be delayed
from being returned to the free memory pool, with a value of zero
meaning that all freed memory allocations will immediately be reused.
Obviously, in an ideal world it would be nice to be able to specify
`NOFREE='_huge-number_ all the time, but this will gradually use up
more and more memory since no system heap memory will ever be reused.
Supplying a smaller number to the `NOFREE' option allows you to make a
compromise by storing the details of only the most recently-freed
memory allocations.  How many details you wish to store is up to you.

   Normally, the `NOFREE' option will cause the library to fill all
freed memory allocations with the free byte.  However, the original
contents of such allocations can be preserved with the `PRESERVE'
option.  This could help in situations when you need to determine
exactly if a program is relying on the contents of freed memory.


File: mpatrol.info,  Node: Example 3,  Next: Example 4,  Prev: Example 2,  Up: Examples

16.3 Detecting use of free memory
=================================

This next example illustrates how the mpatrol library is able to check
to see if anything has been written into free memory.  The test is
located in `tests/fail/test4.c' and simply writes a single byte into
free memory.

     23  /*
     24   * Allocates a block of 16 bytes and then immediately frees it.  A
     25   * NULL character is written into the middle of the freed memory.
     26   */


     29  #include "mpatrol.h"


     32  int main(void)
     33  {
     34      char *p;

     36      if (p = (char *) malloc(16))
     37      {
     38          free(p);
     39          p[8] = '\0';
     40      }
     41      return EXIT_SUCCESS;
     42  }

   The following output was produced as part of `mpatrol.log'.  Note
that this test was run using the same `MPATROL_OPTIONS' settings as the
last example, but make sure that `PRESERVE' is not set.

     ERROR: [FRDCOR]: freed allocation 0x08062F54 has memory corruption at 0x08062F5C
             0x08062F5C  00555555 55555555                    .UUUUUUU

         0x08062F54 (16 bytes) {free:52:0} [main|test4.c|38]
             0x08049456 main+70
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

   The library was able to detect that something had been written into
free memory and could report on the memory allocation that was
overwritten.  However, these checks are only performed whenever a
function in the mpatrol library is called if the `CHECK' option is
used, or at the end of program execution.  In the example above, the
code which wrote into free memory could have been miles away from where
the library detected the error since we were not using the `CHECK'
option.  However, adding `CHECK=-' to the `MPATROL_OPTIONS' environment
variable doesn't really help much since the next mpatrol function that
is called is the one to terminate the library anyway.

   Note that using the `CHECK' option is equivalent to calling
`__mp_check()' when each mpatrol library function is called, or at the
range and frequency specified in the values passed to the `CHECK'
option.  If you suspect that heap corruption is occurring in a part of
your code where there is a large gap between mpatrol library calls, you
can try to narrow the problem down by adding a few calls to
`__mp_check()'.

   On platforms that support memory protection, the library also
supports the `PAGEALLOC' option.  This option instructs the library to
force every single memory allocation to have a size which is a multiple
of the system page size.  Although the library still stores the
original requested size, it effectively means that no two memory
allocations occupy the same page of memory.  It can then use page
protection (which only operates on pages of memory) to protect all free
memory from being read from or written to, and uses similar features to
install a page of overflow buffer on either side of the allocation.

   However, if the requested size for the memory allocation was not a
multiple of the page size this means that there will still be unused
space left over in the allocated pages.  This problem is solved by
turning the unused space into overflow buffers that will be checked in
the normal way.  The positioning of the allocation within its pages is
also important.  If you want to check for illegal reads from the
borders of the memory allocation, unless it fits exactly into its pages
then there is a chance that a program could illegally read the
right-most overflow buffer if the allocation was left-aligned, or
vice-versa.  Two settings therefore exist for the `PAGEALLOC' option:
`LOWER' and `UPPER'.  They refer to the placement of every memory
allocation within its constituent pages.

   The following diagram illustrates the `PAGEALLOC' option.  In the
diagram, the system page size is assumed to be 16 bytes (very unlikely,
but will serve for this example) and each character represents 1 byte.

     x = allocated memory
     o = overflow buffer (filled with the overflow byte)
     . = overflow buffer page (read and write protected)

     PAGEALLOC=LOWER, allocation size is 16 bytes or
     PAGEALLOC=UPPER, allocation size is 16 bytes:
         ................xxxxxxxxxxxxxxxx................

     PAGEALLOC=LOWER, allocation size is 8 bytes:
         ................xxxxxxxxoooooooo................

     PAGEALLOC=UPPER, allocation size is 8 bytes:
         ................ooooooooxxxxxxxx................

   In our original example, if the `PAGEALLOC=LOWER' option is added to
the `MPATROL_OPTIONS' environment variable then the following error
will be produced instead of the original error.

     ERROR: [ILLMEM]: illegal memory access at address 0x081C6008
         0x081C6000 (16 bytes) {free:52:0} [main|test4.c|38]
             0x08049456 main+70
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

         call stack
             0x0804945F main+79
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

   On systems that support memory protection, the mpatrol library has a
built-in signal handler which catches illegal memory accesses and
terminates the program.  In the above case, the freed memory was made
write-protected and so could not be written to.  The underlying virtual
memory system in the operating system noticed this and signaled this to
the library immediately after it happened.

   Along with the details of the freed memory allocation that was being
written to, the library also attempts to display the function call
stack for the location in the program that caused the illegal memory
access, although this can be quite unreliable.  A better solution would
be to run the program in a debugger to catch the illegal memory access.

   Note that the `PAGEALLOC' option also modifies the behaviour of the
`NOFREE' and `PRESERVE' options when used together.  The memory
allocation being freed will always be made write-protected when the
`PRESERVE' option is used, otherwise it will also be made read-protected
to prevent further accesses.

   Note also that the `PAGEALLOC=UPPER' option is potentially much less
efficient at catching illegal memory accesses than the `PAGEALLOC=LOWER'
option.  This is due to alignment requirements, since an allocation of
1 byte requiring an alignment of 16 bytes cannot be placed at the very
end of a page of size 4096 bytes.  The following diagram illustrates
this, using the same page size as the last diagram.

     x = allocated memory
     o = overflow buffer (filled with the overflow byte)
     . = overflow buffer page (read and write protected)

     PAGEALLOC=UPPER, allocation size is 16 bytes, alignment is 8 bytes:
         ................xxxxxxxxxxxxxxxx................

     PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 1 byte:
         ................oooooooooooooxxx................

     PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 8 bytes:
         ................ooooooooxxxooooo................

   Everything is OK until the last allocation, where the alignment
requirement means that there must be two overflow buffers.  This slows
down program execution since the library must check an additional
overflow buffer, and also means that the program would have to read six
bytes beyond the end of the allocation before the illegal memory access
would be detected.


File: mpatrol.info,  Node: Example 4,  Next: Example 5,  Prev: Example 3,  Up: Examples

16.4 Using overflow buffers
===========================

This example illustrates the use of overflow buffers and so the
`MPATROL_OPTIONS' environment variable should have `OFLOWSIZE=2' and
`CHECK=-' added to it.  However, turn off any `PAGEALLOC' options for
the purposes of this example.  The test is located in
`tests/fail/test5.c', and `tests/fail/test6.c' is very similar.

     23  /*
     24   * Allocates a block of 16 bytes and then copies a string of 16
     25   * bytes into the block.  However, the string is copied to 1 byte
     26   * before the allocated block which writes before the start of the
     27   * block.  This test must be run with an OFLOWSIZE greater than 0.
     28   */


     31  #include "mpatrol.h"


     34  int main(void)
     35  {
     36      char *p;

     38      if (p = (char *) malloc(16))
     39      {
     40          strcpy(p - 1, "this test fails!");
     41          free(p);
     42      }
     43      return EXIT_SUCCESS;
     44  }

   The following error should be produced in `mpatrol.log'.

     ERROR: [ALLOVF]: allocation 0x08062FB8 has a corrupted overflow buffer at
                      0x08062FB7
             0x08062FB6  AA74                                 .t

         0x08062FB8 (16 bytes) {malloc:52:0} [main|test5.c|38]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

   Once again, the library attempts to show you as much detail as
possible about where the corruption occurred.  Along with showing you a
memory dump of the overflow buffer that was corrupted, it also shows
you the allocation to which the overflow buffer belongs.

   Using overflow buffers and the `CHECK=-' option can reduce the speed
of program execution since the library has to check every buffer
whenever it is called, and if the buffers are larger then they'll take
longer to check and will use up more memory.  However, larger buffers
mean that there is less chance of the program writing past one memory
allocation into another.

   Alternatively, the `CHECK' option can be used to limit the number of
checks that the library has to perform, thus speeding up program
execution.  This option specifies a range of allocation indices through
which the library will check overflow buffers and free memory for
corruption.  Such checks occur when they normally would, but only if
the current allocation index falls within the specified range.  This
feature can be used when there is a suspicion that free memory
corruption or overflow buffer corruption occurs at a certain point
during program execution, but checking them at every library call would
take too long.  You can also specify a frequency at which to check the
heap using the `CHECK' option.  This can be used when attempting to
narrow down the search for where heap corruption occurs.

   On systems which support software watch points, there is an extra
option called `OFLOWWATCH' which allows additional memory protection.
Watch points allow individual bytes to be read and/or write protected
as opposed to just pages.  The `OFLOWWATCH' option installs software
watch points at every overflow buffer instead of requiring the library
to check the integrity of the overflow buffers, and can be used in
combination with `PAGEALLOC'.  However, software watch points slow down
program execution to a crawl since every machine instruction must be
checked individually by the system to see if it accesses a watch point
area.  Slowing the program down by a factor of 10,000 is not uncommon
on some systems when the `OFLOWWATCH' option is used.


File: mpatrol.info,  Node: Example 5,  Next: Example 6,  Prev: Example 4,  Up: Examples

16.5 Checking memory accesses
=============================

For the ultimate in heap checking, if you are using the GNU compiler
you can use the `-fcheck-memory-usage' option.  This instructs the
compiler to place error-checking calls before each read or write to
memory.  The functions that are called then check to ensure that the
memory access does not overflow a heap memory allocation or access free
memory.

   The following test (which can be found in `tests/fail/test17.c') has
an example of a read from memory which overflows a memory allocation's
boundaries.

     23  /*
     24   * Allocates a single byte of memory and then attempts to read the
     25   * byte as a word, resulting in some uninitialised bytes being read.
     26   * This can sometimes be detected with PAGEALLOC=UPPER but can always
     27   * be detected with OFLOWWATCH or by using the -fcheck-memory-usage
     28   * option of gcc.
     29   */


     32  #include "mpatrol.h"


     35  int main(void)
     36  {
     37      int *p;
     38      int r;

     40      if (p = (int *) calloc(1, 1))
     41      {
     42          r = p[0];
     43          free(p);
     44      }
     45      return EXIT_SUCCESS;
     46  }

   For this example, the above test must be compiled with `gcc' with the
`-fcheck-memory-usage' option on the compiler command line and linked
with the mpatrol library.  Normally, the test will pass and not cause
any problems, since most malloc libraries will allocate at least one
word anyway.  However, there are some instances where that will not be
the case, especially on systems where misaligned memory accesses are
legal.  Also, if the implementation of `calloc()' only initialised the
number of bytes requested then the number read back might not be zero.

   If you now run the program it should abort and produce something
similar to the following in the resulting `mpatrol.log'.

     ERROR: [RNGOVF]: range [0x00022568,0x0002256B] overflows
                      [0x00022568,0x00022568]
         0x00022568 (1 byte) {calloc:19:0} [main|test17.c|40]
             0x00010A0C main+96
             0x0001087C _start+100

   As you can see, the mpatrol library detected a read beyond the
boundaries of the one byte memory allocation starting at `0x00022568'.


File: mpatrol.info,  Node: Example 6,  Next: Example 7,  Prev: Example 5,  Up: Examples

16.6 Bad memory operations
==========================

In C there are several basic memory operation functions that are often
called to perform tasks such as clearing memory, copying memory, etc.
The mpatrol library contains replacements for these which allow for
better checking of their arguments to prevent reading and writing past
the boundaries of existing memory allocations.  The following source
can be found in `tests/fail/test9.c'.

     23  /*
     24   * Allocates a block of 16 bytes and then attempts to zero the contents of
     25   * the block.  However, a zero byte is also written 1 byte before and 1
     26   * byte after the allocated block, resulting in an error in the log file.
     27   */


     30  #include "mpatrol.h"


     33  int main(void)
     34  {
     35      char *p;

     37      if (p = (char *) malloc(16))
     38      {
     39          memset(p - 1, 0, 18);
     40          free(p);
     41      }
     42      return EXIT_SUCCESS;
     43  }

   When this is compiled and run, the following should appear in the
log file.

     ERROR: [RNGOVF]: memset: range [0x08062FB7,0x08062FC8] overflows
                      [0x08062FB8,0x08062FC7]
         0x08062FB8 (16 bytes) {malloc:52:0} [main|test9.c|37]
             0x0804942F main+31
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

   As you can see, the library detected that the `memset()' function
would have written past the boundaries of the memory allocation and
reported this to you.  It then proceeded to ignore the request to copy
the memory and continued with the execution of the program(1).  Note
that this will only be done for known memory allocations.  Reading and
writing past the boundaries of static and stack memory allocations
cannot be detected in this way.

   If the `LOGMEMORY' option is added to the `MPATROL_OPTIONS'
environment variable then it is possible to see a log of all the
mpatrol library memory operation functions that were called during
program execution.  For example, adding this option and running the
above program again will produce something similar to the following.

     MEMSET: memset (0x08062FB7, 18 bytes, 0x00) [main|test9.c|39]
             0x0804945B main+75
             0x4007C9CB __libc_start_main+255
             0x08049381 _start+33

   This is similar to the tracing produced for memory allocation
functions, except that the arguments in parentheses mean different
things.  For `MEMSET', the first argument represents the start of the
memory block to set, the second argument represents the number of bytes
to set and the third argument represents the actual byte to set.

   For `MEMCOPY', the first argument represents the source memory
block, the second argument represents the destination memory block, the
third argument represents the number of bytes to copy and the fourth
argument represents a byte to copy up to if `memccpy()' is being
called.  This is similar for `MEMCMP'.

   For `MEMFIND', the first and second arguments represent the source
memory block and its length, while the third and fourth arguments
represent the memory block to search for and its length.  In the
implementation for `memchr()', the byte to search for is copied to a
one byte buffer and the address of that buffer is used as the memory
block to search for.

   Note that as with the memory allocation functions, `MEMCMP',
`MEMFIND', `MEMCOPY' and `MEMSET' are used to generalise the types of
operations being performed and are followed by the names of the actual
functions being used.  In some cases the functions may use a different
ordering of parameters than that shown.

   ---------- Footnotes ----------

   (1) The error can be turned into a warning with the `ALLOWOFLOW'
option which will also force the operation to be performed.


File: mpatrol.info,  Node: Example 7,  Next: Example 8,  Prev: Example 6,  Up: Examples

16.7 Incompatible function calls
================================

This example illustrates how the mpatrol library checks for calls to
incompatible pairs of memory allocation functions.  It requires the use
of C++, although does not use any C++ features except for overloaded
operators.  The source is in `tests/fail/test7.c', and
`tests/fail/test8.c' is similar.

     23  /*
     24   * Allocates a block of 16 bytes using C++ operator new[] and then
     25   * attempts to free it using C++ operator delete.
     26   */


     29  #include "mpatrol.h"


     32  int main(void)
     33  {
     34      char *p;

     36      p = new char[16];
     37      delete p;
     38      return EXIT_SUCCESS;
     39  }

   The relevant parts of `mpatrol.log' are shown below.

     ALLOC: operator new[] (74, 16 bytes, 4 bytes) [int main()|test7.c|36]
             0x0804955D main+13
             0x400DB9CB __libc_start_main+255
             0x080494C1 _start+33

     returns 0x08062FC0

     FREE: operator delete (0x08062FC0) [int main()|test7.c|37]
             0x0804956E main+30
             0x400DB9CB __libc_start_main+255
             0x080494C1 _start+33

     ERROR: [INCOMP]: operator delete: 0x08062FC0 was allocated with operator new[]
         0x08062FC0 (16 bytes) {operator new[]:74:0} [int main()|test7.c|36]
             0x0804955D main+13
             0x400DB9CB __libc_start_main+255
             0x080494C1 _start+33

   This shows a call to `operator new[]', closely followed by a call to
`operator delete'.  However, in C++ calls to `operator new[]' must be
matched by calls to `operator delete[]' and not `operator delete'.
Hence, the library reports this as an error and does not free the memory
allocation.


File: mpatrol.info,  Node: Example 8,  Next: Example 9,  Prev: Example 7,  Up: Examples

16.8 The `alloca()' functions
=============================

There are two examples of using `alloca()' and its related functions in
`tests/pass/test8.c' and `tests/fail/test16.c'.  Both rely on mpatrol
having full call stack traceback support, although they will work
(albeit with slightly different results) on systems that do not.

   The first test simply illustrates the use of `alloca()' and how its
memory allocations are freed when they are no longer in use.

      23  /*
      24   * Tests alloca() and related functions via nested function calls.
      25   * The final output should be a horizontal pyramid of plus signs
      26   * followed by a horizontal pyramid of minus signs.
      27   */


      30  #include "mpatrol.h"
      31  #include <stdio.h>


      34  char *f1(char *s)
      35  {
      36      char *t;
      37      size_t l;

      39      l = strlen(s) + 1;
      40      if ((t = (char *) alloca(l + 1)) == NULL)
      41          return NULL;
      42      memcpy(t, s, l);
      43      t[l - 1] = t[l - 2];
      44      t[l] = '\0';
      45      return strdup(t);
      46  }


      49  char *f2(char *s)
      50  {
      51      char *t;
      52      size_t l;

      54      l = strlen(s) - 1;
      55      if ((t = (char *) alloca(l + 1)) == NULL)
      56          return NULL;
      57      memcpy(t, s, l + 1);
      58      t[l] = '\0';
      59      return strdup(t);
      60  }


      63  int f(char *s, size_t l)
      64  {
      65      char *t;
      66      size_t i;

      68      puts(s);
      69      for (i = 0; i < l; i++)
      70      {
      71          if (((t = f1(s)) == NULL) ||
      72              ((s = (char *) alloca(strlen(t) + 1)) == NULL))
      73              return 0;
      74          strcpy(s, t);
      75          free(t);
      76          puts(s);
      77      }
      78      for (i = 0; i < l; i++)
      79      {
      80          if (((t = f2(s)) == NULL) ||
      81              ((s = (char *) alloca(strlen(t) + 1)) == NULL))
      82              return 0;
      83          strcpy(s, t);
      84          free(t);
      85          puts(s);
      86      }
      87      return 1;
      88  }


      91  int main(void)
      92  {
      93      char *s;

      95      s = strdupa("+");
      96      if (!f(s, 4))
      97          exit(EXIT_FAILURE);
      98      dealloca(s);
      99      s = strdupa("-");
     100      if (!f(s, 4))
     101          exit(EXIT_FAILURE);
     102      dealloca(s);
     103      return EXIT_SUCCESS;
     104  }

   When compiled and run, you should get the following output.

     +
     ++
     +++
     ++++
     +++++
     ++++
     +++
     ++
     +
     -
     --
     ---
     ----
     -----
     ----
     ---
     --
     -

   If you run it again, this time with the `MPATROL_OPTIONS' environment
variable set to `LOGALLOCS' and `LOGFREES', you should see the
following in the newly-generated `mpatrol.log' file.  Note that the
`...' marks text that has been removed.

     ALLOC: strdupa (1, 2 bytes, 1 byte) [main|test8.c|95] (char x 2)
             0x000138F0 main+52
             0x00013350 _start+100

     returns 0x0008C000

     ALLOC: alloca (2, 3 bytes, 8 bytes) [f1|test8.c|40]
             0x000134CC f1+76
             0x000136D8 f+68
             0x00013904 main+72
             0x00013350 _start+100

     returns 0x0008C008

     ALLOC: strdup (3, 3 bytes, 1 byte) [f1|test8.c|45] (char x 3)
             0x00013584 f1+260
             0x000136D8 f+68
             0x00013904 main+72
             0x00013350 _start+100

     returns 0x0008C002

     FREE: alloca (0x0008C008) [f|test8.c|72]
             0x00013728 f+148
             0x00013904 main+72
             0x00013350 _start+100

         0x0008C008 (3 bytes) {alloca:2:0} [f1|test8.c|40]
             0x000134CC f1+76
             0x000136D8 f+68
             0x00013904 main+72
             0x00013350 _start+100

     ALLOC: alloca (4, 3 bytes, 8 bytes) [f|test8.c|72]
             0x00013728 f+148
             0x00013904 main+72
             0x00013350 _start+100

     returns 0x0008C008

     ...

     FREE: alloca (0x0008C040) [main|test8.c|102]
             0x000139C8 main+268
             0x00013350 _start+100

         0x0008C040 (2 bytes) {alloca:50:0} [f|test8.c|81]
             0x00013828 f+404
             0x00013988 main+204
             0x00013350 _start+100

     FREE: alloca (0x0008C038) [main|test8.c|102]
             0x000139C8 main+268
             0x00013350 _start+100

         0x0008C038 (3 bytes) {alloca:47:0} [f|test8.c|81]
             0x00013828 f+404
             0x00013988 main+204
             0x00013350 _start+100

     ...

     FREE: alloca (0x0008C010) [main|test8.c|102]
             0x000139C8 main+268
             0x00013350 _start+100

         0x0008C010 (4 bytes) {alloca:32:0} [f|test8.c|72]
             0x00013728 f+148
             0x00013988 main+204
             0x00013350 _start+100

     FREE: alloca (0x0008C008) [main|test8.c|102]
             0x000139C8 main+268
             0x00013350 _start+100

         0x0008C008 (3 bytes) {alloca:29:0} [f|test8.c|72]
             0x00013728 f+148
             0x00013988 main+204
             0x00013350 _start+100

     FREE: dealloca (0x0008C000) [main|test8.c|102]
             0x000139C8 main+268
             0x00013350 _start+100

         0x0008C000 (2 bytes) {strdupa:26:0} [main|test8.c|99] (char x 2)
             0x00013974 main+184
             0x00013350 _start+100

   After the first call to `strdupa()', there is a call to `alloca()'
followed by a call to `strdup()'.  Because the memory allocation made by
`strdupa()' is at the top level of the program it cannot automatically
be freed until `main()' returns.  However, at the next call to
`alloca()' in `f()', the mpatrol library notices that the memory
allocation that was made by `alloca()' in `f1()' can be freed since
`f1()' has returned.  The relevant allocation is then freed before
making the next memory allocation.  You can see how it makes its
decision by examining the call stack at the point of deallocation.

   However, all of the memory allocations made by `alloca()' in `f()'
cannot be freed until `f()' returns.  This can be seen in the two sets
of eight consecutive deallocations in the log file, each set followed
by a call to `dealloca()'.  The `dealloca()' function explicitly frees
a memory allocation that was made by the `alloca()' family of
functions, but these calls are not really necessary as all of these
memory allocations would be freed anyway when `main()' returns.  The
call to `dealloca()' is really only necessary to force a deallocation
for a specific purpose at a certain point in the program.  Note that
implicit deallocations are marked as being done by `alloca()' while
explicit deallocations are marked as being done by `dealloca()'.

   The second test illustrates how the mpatrol library can help debug
`alloca()'-related problems by treating such memory allocations as
normal heap allocations.

     23  /*
     24   * Duplicates a string using alloca() and then returns the address
     25   * of the allocation.  This is illegal since the memory allocated
     26   * by alloca() will be freed when the function returns.  The call
     27   * to memcpy() will then corrupt free memory and the call to free()
     28   * will attempt to free an invalid pointer.
     29   */


     32  #include "mpatrol.h"
     33  #include <stdio.h>


     36  char *f(size_t l)
     37  {
     38      return (char *) alloca(l);
     39  }


     42  char *g(char *s)
     43  {
     44      char *t;
     45      size_t l;

     47      l = strlen(s) + 1;
     48      if (t = f(l))
     49          memcpy(t, s, l);
     50      return t;
     51  }


     54  int main(void)
     55  {
     56      char *s;

     58      s = g("test");
     59      free(s);
     60      return EXIT_SUCCESS;
     61  }

   If you compile and run this example with the `MPATROL_OPTIONS'
environment variable containing the options `LOGALL' and `NOFREE=1' you
should see the following in `mpatrol.log'.

     ALLOC: alloca (1, 5 bytes, 8 bytes) [f|test16.c|38]
             0x0001346C f+52
             0x000134A8 g+40
             0x00013524 main+20
             0x00013308 _start+100

     returns 0x0008C000

     FREE: alloca (0x0008C000) [g|test16.c|49]
             0x000134F8 g+120
             0x00013524 main+20
             0x00013308 _start+100

         0x0008C000 (5 bytes) {alloca:1:0} [f|test16.c|38]
             0x0001346C f+52
             0x000134A8 g+40
             0x00013524 main+20
             0x00013308 _start+100

     MEMCOPY: memcpy (0x0001F760, 0x0008C000, 5 bytes, 0x00) [g|test16.c|49]
             0x000134F8 g+120
             0x00013524 main+20
             0x00013308 _start+100

     ERROR: [FRDOPN]: memcpy: attempt to perform operation on freed memory
         0x0008C000 (5 bytes) {alloca:1:0} [g|test16.c|49]
             0x000134F8 g+120
             0x00013524 main+20
             0x00013308 _start+100

     returns 0x0008C000

     FREE: free (0x0008C000) [main|test16.c|59]
             0x00013550 main+64
             0x00013308 _start+100

     ERROR: [PRVFRD]: free: 0x0008C000 was freed with alloca
         0x0008C000 (5 bytes) {alloca:1:0} [g|test16.c|49]
             0x000134F8 g+120
             0x00013524 main+20
             0x00013308 _start+100

   As you can see, memory allocations made by `alloca()' are treated in
almost exactly the same way as normal memory allocations, with the
result that errors similar to those above can be detected by the
mpatrol library.  The only real difference between the two types of
memory allocations is that allocations made by the `alloca()' family of
functions will never show up in the list of unfreed memory allocations.


File: mpatrol.info,  Node: Example 9,  Next: Example 10,  Prev: Example 8,  Up: Examples

16.9 The `MP_MALLOC()' functions
================================

The mpatrol library comes with a set of alternative dynamic memory
allocation functions for C.  These allow it to record the type and type
size of every memory allocation made through these functions, which can
be very useful for debugging purposes.  It also means that the
alignment for each memory allocation can be determined according to its
type.  The following test can be found in `tests/pass/test9.c'.

     23  /*
     24   * Allocates 16 floats and then resizes the allocation to 8 floats and
     25   * frees them.  Then allocates 16 integers and resizes the allocation
     26   * to 32 integers before freeing them.  Finally, duplicates a string
     27   * and then frees it.
     28   */


     31  #include "mpatrol.h"


     34  int main(void)
     35  {
     36      float *f;
     37      int *i;
     38      char *s;

     40      MP_MALLOC(f, 16, float);
     41      MP_REALLOC(f, 8, float);
     42      MP_FREE(f);
     43      MP_CALLOC(i, 16, int);
     44      MP_REALLOC(i, 32, int);
     45      MP_FREE(i);
     46      MP_STRDUP(s, "test");
     47      MP_FREE(s);
     48      return EXIT_SUCCESS;
     49  }

   If this test is compiled and linked with the mpatrol library and
then run with the `LOGALL' option, the following output will be seen in
the mpatrol log file.

     ALLOC: xmalloc (84, 64 bytes, 4 bytes) [main|test9.c|40] (float x 16)
             0x0804AC36 main+38
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

     returns 0x080510E8

     REALLOC: xrealloc (0x080510E8, 32 bytes, 4 bytes) [main|test9.c|41] (float x 8)
             0x0804AC60 main+80
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

         0x080510E8 (64 bytes) {xmalloc:84:0} [main|test9.c|40] (float x 16)
             0x0804AC36 main+38
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

     returns 0x080510E8

     FREE: xfree (0x080510E8) [main|test9.c|42]
             0x0804AC7F main+111
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

         0x080510E8 (32 bytes) {xrealloc:84:1} [main|test9.c|41] (float x 8)
             0x0804AC60 main+80
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

     ALLOC: xcalloc (85, 64 bytes, 4 bytes) [main|test9.c|43] (int x 16)
             0x0804ACB2 main+162
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

     returns 0x080510E8

     REALLOC: xrealloc (0x080510E8, 128 bytes, 4 bytes) [main|test9.c|44] (int x 32)
             0x0804ACDF main+207
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

         0x080510E8 (64 bytes) {xcalloc:85:0} [main|test9.c|43] (int x 16)
             0x0804ACB2 main+162
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

     returns 0x080510E8

     FREE: xfree (0x080510E8) [main|test9.c|45]
             0x0804ACFE main+238
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

         0x080510E8 (128 bytes) {xrealloc:85:1} [main|test9.c|44] (int x 32)
             0x0804ACDF main+207
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

     ALLOC: xstrdup (86, 5 bytes, 1 byte) [main|test9.c|46] (char x 5)
             0x0804AD2E main+286
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

     returns 0x080510E5

     FREE: xfree (0x080510E5) [main|test9.c|47]
             0x0804AD4F main+319
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

         0x080510E5 (5 bytes) {xstrdup:86:0} [main|test9.c|46] (char x 5)
             0x0804AD2E main+286
             0x400A09CB __libc_start_main+255
             0x0804AB81 _start+33

   As you can see, the type and number of items allocated of that type
are associated with each memory allocation.  The function names that
are logged as having made the memory allocations are from the
`xmalloc()' family of functions since that is how the `MP_MALLOC()'
family of functions are implemented.


File: mpatrol.info,  Node: Example 10,  Prev: Example 9,  Up: Examples

16.10 Additional useful information
===================================

This last example illustrates the various `SHOW' options that are
available for displaying additional information from the mpatrol
library at program termination.  It also shows how to easily detect
memory leaks.  Use the `OFLOWSIZE=16', `NOFREE=16' and `SHOWALL'
options in `MPATROL_OPTIONS' before running.

      1  /*
      2   * Introduces a memory leak by clobbering a pointer with a new
      3   * memory allocation.  Use with SHOWUNFREED to display it.
      4   */


      7  #include "mpatrol.h"


     10  int main(void)
     11  {
     12      void *p;

     14      p = malloc(4);
     15      p = malloc(4);
     16      if (p != NULL)
     17          free(p);
     18      return EXIT_SUCCESS;
     19  }

   The information that we are interested in comes after the summary of
library statistics generated in the log file.  The first block of data
shows a memory map of the heap that is being handled by mpatrol.  This
can be used to see graphically where a particular allocation is
located, or to look for memory fragmentation.  The `SHOWMAP' option
also displays this information.

   Note that gaps in the memory map can either be due to space used by
internal memory blocks or to some other memory allocation library using
up space.  On some systems that don't have virtual memory, gaps are
likely to be owned by other processes or belong to the system free
memory list.  The `...' marks text that has been removed.

     memory map:
         ...
       / 0x0002FDD0-0x0002FDDF overflow (16 bytes)
      |+ 0x0002FDE0-0x0002FE03 allocated (36 bytes) {calloc:13:0} [-|-|-]
       \ 0x0002FE04-0x0002FE13 overflow (16 bytes)
     --- 0x0002FE14-0x0002FE17 free (4 bytes)
       / 0x0002FE18-0x0002FE27 overflow (16 bytes)
      |+ 0x0002FE28-0x0002FF18 allocated (241 bytes) {calloc:15:0} [-|-|-]
       \ 0x0002FF19-0x0002FF28 overflow (16 bytes)
     --- 0x0002FF29-0x0002FF2F free (7 bytes)
       / 0x0002FF30-0x0002FF3F overflow (16 bytes)
      |+ 0x0002FF40-0x0002FF93 allocated (84 bytes) {calloc:16:0} [-|-|-]
       \ 0x0002FF94-0x0002FFA3 overflow (16 bytes)
     --- 0x0002FFA4-0x0002FFA7 free (4 bytes)
       / 0x0002FFA8-0x0002FFB7 overflow (16 bytes)
      |+ 0x0002FFB8-0x0002FFC4 allocated (13 bytes) {calloc:17:0} [-|-|-]
       \ 0x0002FFC5-0x0002FFD4 overflow (16 bytes)
     --- 0x0002FFD5-0x0002FFD7 free (3 bytes)
       / 0x0002FFD8-0x0002FFE7 overflow (16 bytes)
      |+ 0x0002FFE8-0x0002FFEB allocated (4 bytes) {malloc:19:0} [main|test.c|14]
       \ 0x0002FFEC-0x0002FFFB overflow (16 bytes)
     --- 0x0002FFFC-0x0002FFFF free (4 bytes)
         --------------------- gap (57344 bytes)
       / 0x0003E000-0x0003E00F overflow (16 bytes)
      |+ 0x0003E010-0x0003EFFF freed (4080 bytes) {free:6:0} [-|-|-]
       \ 0x0003F000-0x0003F00F overflow (16 bytes)
       / 0x0003F010-0x0003F01F overflow (16 bytes)
      |+ 0x0003F020-0x0003F707 freed (1768 bytes) {free:12:0} [-|-|-]
       \ 0x0003F708-0x0003F717 overflow (16 bytes)
     --- 0x0003F718-0x0003FFFF free (2280 bytes)
         --------------------- gap (16384 bytes)
       / 0x00044000-0x0004400F overflow (16 bytes)
      |+ 0x00044010-0x00045197 freed (4488 bytes) {free:8:0} [-|-|-]
       \ 0x00045198-0x000451A7 overflow (16 bytes)
       / 0x000451A8-0x000451B7 overflow (16 bytes)
      |+ 0x000451B8-0x000459AF freed (2040 bytes) {free:10:0} [-|-|-]
       \ 0x000459B0-0x000459BF overflow (16 bytes)
       / 0x000459C0-0x000459CF overflow (16 bytes)
      |+ 0x000459D0-0x00045D93 allocated (964 bytes) {calloc:14:0} [-|-|-]
       \ 0x00045D94-0x00045DA3 overflow (16 bytes)
       / 0x00045DA4-0x00045DB3 overflow (16 bytes)
      |+ 0x00045DB4-0x00045DCE allocated (27 bytes) {strdup:18:0} [-|-|-]
       \ 0x00045DCF-0x00045DDE overflow (16 bytes)
     --- 0x00045DDF-0x00045DDF free (1 byte)
       / 0x00045DE0-0x00045DEF overflow (16 bytes)
      |+ 0x00045DF0-0x00045DF3 freed (4 bytes) {free:20:0} [main|test.c|17]
       \ 0x00045DF4-0x00045E03 overflow (16 bytes)
     --- 0x00045E04-0x00045FFF free (508 bytes)

   The next block of data shows a summary of all the symbols that could
be read from the program's executable file and/or any shared libraries
that the program requires.  This can be useful to see which symbols
have actually been read by the mpatrol library.  The `SHOWSYMBOLS'
option also displays this information.

   Note that the following data has been dramatically cut down in size
for the purposes of this example.  The `...' marks text that has been
removed.

     symbols read: 3300
                    0x000108B0 _ex_text0 [a.out] (0 bytes)
         0x000108B0-0x0001097F _start [a.out] (208 bytes)
         0x00010990-0x00010A27 main [a.out] (152 bytes)
                    0x00010A28 _ex_text1 [a.out] (0 bytes)
         0x00010A28-0x00010A77 _init [a.out] (80 bytes)
         0x00010A78-0x00010AC7 _fini [a.out] (80 bytes)
                    0x7FA1FFF8 _ex_text0 [/usr/lib/libc.so.1] (0 bytes)
         0x7FA1FFF8-0x7FA2005F atexit [/usr/lib/libc.so.1] (104 bytes)
         0x7FA20060-0x7FA200EF _exithandle [/usr/lib/libc.so.1] (144 bytes)
         0x7FA20470-0x7FA204EB __dtou [/usr/lib/libc.so.1] (124 bytes)
         0x7FA20500-0x7FA20577 __ftou [/usr/lib/libc.so.1] (120 bytes)
         0x7FA2083C-0x7FA20B2F __div64 [/usr/lib/libc.so.1] (756 bytes)
         0x7FA20B30-0x7FA20DEB __rem64 [/usr/lib/libc.so.1] (700 bytes)
         ...
         0x7FA96858-0x7FA96867 getpid [/usr/lib/libc.so.1] (16 bytes)
         0x7FA96858-0x7FA96867 _getpid [/usr/lib/libc.so.1] (16 bytes)
         0x7FA96868-0x7FA9689F _kill [/usr/lib/libc.so.1] (56 bytes)
         0x7FA96868-0x7FA9689F _libc_kill [/usr/lib/libc.so.1] (56 bytes)
                    0x7FA968A0 _ex_text1 [/usr/lib/libc.so.1] (0 bytes)
         0x7FA968A0-0x7FA968DF _init [/usr/lib/libc.so.1] (64 bytes)
         0x7FA968E0-0x7FA9691F _fini [/usr/lib/libc.so.1] (64 bytes)
         0x7FB105E4-0x7FB1069F memmove [/usr/lib/libc_psr.so.1] (188 bytes)
         0x7FB105E4-0x7FB1069F _memmove [/usr/lib/libc_psr.so.1] (188 bytes)
                    0x7FB106A0 forcpy [/usr/lib/libc_psr.so.1] (0 bytes)
         0x7FB106A0-0x7FB1190B memcpy [/usr/lib/libc_psr.so.1] (4716 bytes)
         0x7FB106A0-0x7FB1190B _memcpy [/usr/lib/libc_psr.so.1] (4716 bytes)
         0x7FB106A0-0x7FB1190B __align_cpy_1 [/usr/lib/libc_psr.so.1] (4716 bytes)
         ...
         0x7FB135B0-0x7FB135D3 __div64 [/usr/lib/libc_psr.so.1] (36 bytes)
         0x7FB135D4-0x7FB135F7 __udiv64 [/usr/lib/libc_psr.so.1] (36 bytes)
         0x7FB135F8-0x7FB1362B __umul64 [/usr/lib/libc_psr.so.1] (52 bytes)
         0x7FB135F8-0x7FB1362B __mul64 [/usr/lib/libc_psr.so.1] (52 bytes)
         0x7FB1362C-0x7FB13657 __urem64 [/usr/lib/libc_psr.so.1] (44 bytes)
         0x7FB13658-0x7FB13683 __rem64 [/usr/lib/libc_psr.so.1] (44 bytes)
                    0x7FB333F8 _ex_text0 [/usr/lib/libelf.so.1] (0 bytes)
         0x7FB333F8-0x7FB3346F _elf32_entsz [/usr/lib/libelf.so.1] (120 bytes)
         0x7FB33470-0x7FB334EB elf32_fsize [/usr/lib/libelf.so.1] (124 bytes)
         0x7FB33470-0x7FB334EB _elf32_fsize [/usr/lib/libelf.so.1] (124 bytes)
         0x7FB334EC-0x7FB3352F _elf32_msize [/usr/lib/libelf.so.1] (68 bytes)
         0x7FB33530-0x7FB335D3 _elf32_mtype [/usr/lib/libelf.so.1] (164 bytes)
         ...
         0x7FB49054-0x7FB4921F _elf_nlist [/usr/lib/libelf.so.1] (460 bytes)
         0x7FB49220-0x7FB4932F nlist [/usr/lib/libelf.so.1] (272 bytes)
         0x7FB49330-0x7FB493E3 _elf_findop [/usr/lib/libelf.so.1] (180 bytes)
                    0x7FB493E4 _ex_text1 [/usr/lib/libelf.so.1] (0 bytes)
         0x7FB493E4-0x7FB4941B _init [/usr/lib/libelf.so.1] (56 bytes)
         0x7FB4941C-0x7FB49453 _fini [/usr/lib/libelf.so.1] (56 bytes)
         0x7FB65818-0x7FB6582F __mp_newlist [/usr/lib/libmpatrol.so.1.3] (24 bytes)
         0x7FB65830-0x7FB65853 __mp_addhead [/usr/lib/libmpatrol.so.1.3] (36 bytes)
         0x7FB65854-0x7FB6587B __mp_addtail [/usr/lib/libmpatrol.so.1.3] (40 bytes)
         0x7FB6587C-0x7FB6589F __mp_prepend [/usr/lib/libmpatrol.so.1.3] (36 bytes)
         0x7FB658A0-0x7FB658C3 __mp_insert [/usr/lib/libmpatrol.so.1.3] (36 bytes)
         0x7FB658C4-0x7FB658EB __mp_remove [/usr/lib/libmpatrol.so.1.3] (40 bytes)
         ...
         0x7FB725F4-0x7FB7262B memmem [/usr/lib/libmpatrol.so.1.3] (56 bytes)
         0x7FB7262C-0x7FB72663 _memmem [/usr/lib/libmpatrol.so.1.3] (56 bytes)
         0x7FB72664-0x7FB72697 memcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
         0x7FB72698-0x7FB726CB _memcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
         0x7FB726CC-0x7FB726FF bcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
         0x7FB72700-0x7FB72733 _bcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
         0x7FB9085C-0x7FB90863 dlinfo [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB9085C-0x7FB90863 _dlinfo [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB90864-0x7FB9086B dlmap [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB90864-0x7FB9086B _dlmap [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB9086C-0x7FB90873 dlmopen [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB9086C-0x7FB90873 _dlmopen [/usr/lib/libdl.so.1] (8 bytes)
         ...
         0x7FB90894-0x7FB9089B dladdr [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB90894-0x7FB9089B _dladdr [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB9089C-0x7FB908A3 dldump [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB9089C-0x7FB908A3 _dldump [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB908A4-0x7FB908AB _ld_concurrency [/usr/lib/libdl.so.1] (8 bytes)
         0x7FB908AC-0x7FB908B3 bind_guard [/usr/lib/libdl.so.1] (8 bytes)

   The next table is really only useful for seeing how much memory
fragmentation has occurred in the memory map.  It shows a breakdown of
the free memory blocks that have either resulted from the mpatrol
library allocating uninitialised memory from the system heap or from
freeing existing memory allocations.  The column on the left shows the
size of the free block in bytes and the column on the right shows the
number of blocks of that size that are available.  The `SHOWFREE'
option also displays this information.

     free blocks: 10 (2919 bytes)
            2280: 1
             508: 1
              76: 1
              32: 1
               7: 1
               4: 3
               3: 1
               1: 1

   The next block of data shows a summary of all freed memory
allocations.  This is only possible because the `NOFREE' option was
also given, otherwise there would be no details on freed memory
allocations.  All of these entries show where the allocation was freed,
which can be useful if you quickly needed to see where an allocation
was freed.  The `SHOWFREED' option also displays this information.
Note that the list will be limited to the size of the freed queue and
will show only the most recently-freed items.

   As this example was run on UNIX, the mpatrol library replaces the
default implementations of `malloc()', `free()', etc.  As can be seen
below, this allows the library to trace all calls to allocate dynamic
memory in a process, even from functions that were not compiled with
mpatrol.  Four of the five functions shown below were called by the
mpatrol library in order to read the symbols from ELF object files.
However, they are located in the ELF access library which was not
compiled with mpatrol.

   Note that the following data has again been cut down in size for the
purposes of this example.  The `...' marks text that has been removed.

     freed allocations: 13 (19756 bytes)
         0x0002E010 (232 bytes) {free:1:0} [-|-|-]
             0x7FB3E5BC _elf_end+776
             0x7FB6B3D4 __mp_addsymbols+440
             0x7FB6FF5C __mp_init+208
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         0x0002E118 (3536 bytes) {free:2:0} [-|-|-]
             0x7FB3E450 _elf_end+412
             0x7FB6B3D4 __mp_addsymbols+440
             0x7FB6FF5C __mp_init+208
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         0x0002EF08 (232 bytes) {free:3:0} [-|-|-]
             0x7FB3E5BC _elf_end+776
             0x7FB6B3D4 __mp_addsymbols+440
             0x7FB6B4B4 __mp_addextsymbols+208
             0x7FB6FF64 __mp_init+216
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         0x0002F010 (2448 bytes) {free:4:0} [-|-|-]
             0x7FB3E450 _elf_end+412
             0x7FB6B3D4 __mp_addsymbols+440
             0x7FB6B4B4 __mp_addextsymbols+208
             0x7FB6FF64 __mp_init+216
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         ...

         0x00045DF0 (4 bytes) {free:20:0} [main|test.c|17]
             0x00010A14 main+132
             0x00010970 _start+192

   The final block of data shows a summary of all unfreed memory
allocations.  This can show up memory leaks, although all but one of
the unfreed memory allocations in this example come from the standard C
library.  On systems such as UNIX it does not really matter about these
unfreed allocations since they will automatically be returned to the
system on process termination.

   However, the other unfreed allocation shows an example of a memory
leak, where no pointers referencing that allocation remain in the
program to free it with.  If this was within a loop then the program
could quickly run away with memory, causing at least a decrease in
performance, and at most a memory shortage.  The mpatrol library makes
it easier to spot memory leaks, especially if the `PROF' profiling
option is used.

   The `SHOWUNFREED' option also displays this information.

     unfreed allocations: 7 (1369 bytes)
         0x0002FDE0 (36 bytes) {calloc:13:0} [-|-|-]
             0x7FA54B7C _tzload+56
             0x7FA53990 _ltzset_u+444
             0x7FA52D98 localtime_u+28
             0x7FA3AF20 ctime+12
             0x7FB6D05C __mp_printversion+184
             0x7FB6FFA0 __mp_init+276
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         0x0002FE28 (241 bytes) {calloc:15:0} [-|-|-]
             0x7FA54E3C _tzload+760
             0x7FA53990 _ltzset_u+444
             0x7FA52D98 localtime_u+28
             0x7FA3AF20 ctime+12
             0x7FB6D05C __mp_printversion+184
             0x7FB6FFA0 __mp_init+276
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         0x0002FF40 (84 bytes) {calloc:16:0} [-|-|-]
             0x7FA54E64 _tzload+800
             0x7FA53990 _ltzset_u+444
             0x7FA52D98 localtime_u+28
             0x7FA3AF20 ctime+12
             0x7FB6D05C __mp_printversion+184
             0x7FB6FFA0 __mp_init+276
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         0x0002FFB8 (13 bytes) {calloc:17:0} [-|-|-]
             0x7FA54EE8 _tzload+932
             0x7FA53990 _ltzset_u+444
             0x7FA52D98 localtime_u+28
             0x7FA3AF20 ctime+12
             0x7FB6D05C __mp_printversion+184
             0x7FB6FFA0 __mp_init+276
             0x7FB701FC __mp_alloc+84
             0x000109B8 main+40
             0x00010970 _start+192

         0x0002FFE8 (4 bytes) {malloc:19:0} [main|test.c|14]
             0x000109B8 main+40
             0x00010970 _start+192

         ...

   Beginning with mpatrol release 1.4.2, the `LEAKTABLE' option is
available to summarise the above unfreed memory allocations without
including the internal memory allocations that were made when the
mpatrol library was initialised.  If you add the `LEAKTABLE' option to
the `MPATROL_OPTIONS' environment variable and then re-run the program
you should see the following in the mpatrol log file:

     top 1 unfreed memory entry in leak table:

            bytes   count  location
         --------  ------  --------
                4       1  test.c line 14
                4       1  total


File: mpatrol.info,  Node: Tutorial,  Next: Functions,  Prev: Examples,  Up: Top

17 Tutorial
***********

In this chapter we'll look at a real example of using the mpatrol
library to debug a program.  All of the following building and
debugging steps were performed on an Intel Linux machine so the details
may differ slightly on your system, but the concepts should remain the
same.  However, on systems without virtual memory some of the steps may
actually cause the machine to lock up or crash so be aware of this if
you are running such a system -- you may be safer just reading this
tutorial rather than attempting it!

   This tutorial will also make use of the option `USEDEBUG' which
displays source-level file names and line numbers associated with
symbols in call stack tracebacks, but only if the underlying object
file access library supports reading line tables from object files and
even then only if the object files were compiled with debugging
information enabled.  Alternatively, you may be able to use the `mpsym'
command to obtain such information instead.

   The program we are going to look at is a simple filter which
processes its standard input and displays the processed information on
its standard output.  In this case the program converts all lowercase
characters to uppercase and removes any blank lines.  The source for
the program is given below, but can also be found in
`tests/tutorial/test1.c'.

     23  /*
     24   * Reads the standard input file stream, converts all lowercase
     25   * characters to uppercase, and displays all non-empty lines to the
     26   * standard output file stream.
     27   */


     30  #include <stdio.h>
     31  #include <stdlib.h>
     32  #include <string.h>
     33  #include <ctype.h>


     36  char *strtoupper(char *s)
     37  {
     38      char *t;
     39      size_t i, l;

     41      l = strlen(s);
     42      t = (char *) malloc(l);
     43      for (i = 0; i < l; i++)
     44          t[i] = toupper(s[i]);
     45      t[i] = '\0';
     46      return t;
     47  }


     50  int main(void)
     51  {
     52      char *b, *s;

     54      b = (char *) malloc(BUFSIZ);
     55      while (gets(b))
     56      {
     57          s = strtoupper(b);
     58          if (*s != '\0')
     59          {
     60              puts(s);
     61              free(s);
     62          }
     63      }
     64      free(b);
     65      return EXIT_SUCCESS;
     66  }

   If you quickly skimmed over the above code then you might have
noticed some rather obvious errors, but there are also some less
obvious ones hidden there as well.  After compiling and linking with
the system C compiler and libraries it successfully runs, even when its
source code is piped to it.  So if it runs, why bother trying to debug
it?

   The short answer to that is that this program does in fact contain
one rather major error that is likely to prevent it from running
portably on other systems.  However, for the purposes of this tutorial,
we'll pretend that we've just been handed the source code for this
program and have not worked on it before.  So let's now try to compile
and link it with the mpatrol library(1).

   First, add the inclusion of `mpatrol.h' to line 34 so that we can
replace calls to `malloc()' and `free()' with their mpatrol
equivalents(2).  Then, recompile the program and link it with the
mpatrol library.  This time, running it with the `CHECK=-' option and
even the simplest of non-empty input lines should cause it to abort!

   If you look at the `mpatrol.log' file produced, you should see
something along the lines of the following at the end of the log file.

     ERROR: [FRECOR]: free memory corruption at 0x08067FF6
             0x08067FF6  00555555 55555555 5555               .UUUUUUUUU

   This tells us that something has written a zero byte into free
memory at location `0x08067FF6'.  Unfortunately, the library only
caught it at the next call to one of its functions so it had already
happened somewhere in between the last call and the current call.
Turning on the `LOGALL' option in the `MPATROL_OPTIONS' environment
variable allows us to see the last successful function call to the
mpatrol library.

     ALLOC: malloc (56, 8192 bytes, 4 bytes) [main|test1.c|54]
             0x0804960E main+34 at test1.c:54
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

     returns 0x080F0B48

     ALLOC: malloc (68, 2 bytes, 4 bytes) [strtoupper|test1.c|42]
             0x08049592 strtoupper+50 at test1.c:42
             0x08049631 main+69 at test1.c:57
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

     returns 0x08067FF4

   Unfortunately, this only tells us that the last successful mpatrol
library function call was `malloc()' called from `strtoupper()'.  If we
add the option `OFLOWSIZE=8' to the `MPATROL_OPTIONS' environment
variable then we get slightly more information about which memory
allocation was affected(3).

     ERROR: [ALLOVF]: allocation 0x08071E34 has a corrupted overflow buffer at
                      0x08071E36
             0x08071E36  00AAAAAA AAAAAAAA                    ........

         0x08071E34 (2 bytes) {malloc:68:0} [strtoupper|test1.c|42]
             0x08049592 strtoupper+50 at test1.c:42
             0x08049631 main+69 at test1.c:57
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

   Now we can make a better guess about what is happening.  Since the
start of the upper overflow buffer of allocation 68 has been written
to, we can assume that something has written one byte beyond the end of
that memory allocation.  You can probably see where that is happening
now by looking at the code, but let's try to be even more sure that
this is what is wrong.

   The only foolproof way to do this is to add a watch point to keep an
eye on the address that is being written to.  This can normally only be
done within a debugger, but on systems that support programmable
software watch points, the `OFLOWWATCH' option can be used to do the
same thing.  For the sake of generality, we'll use the debugger watch
point approach, in this case with `gdb'.  In order for the following
example to work correctly you'll need to add the `ALLOCSTOP=68' option
to the `MPATROL_OPTIONS' environment variable so that we can stop just
after the last successful memory allocation.

     (gdb) break main
     Breakpoint 1 at 0x80495f2: file test1.c, line 54.
     (gdb) run <test1.c
     Starting program: a.out
     Breakpoint 1, main() at test1.c:54
     54          b = (char *) malloc(BUFSIZ);
     (gdb) break __mp_trap
     Breakpoint 2 at 0x804f083
     (gdb) continue
     Continuing.
     Breakpoint 2, 0x804f083 in __mp_trap()
     (gdb) backtrace
     #0  0x804f083 in __mp_trap()
     #1  0x804c81b in __mp_getmemory()
     #2  0x8049a94 in __mp_alloc()
     #3  0x8049592 in strtoupper(s=0x80f0be0 "/*") at test1.c:42
     #4  0x8049631 in main() at test1.c:57
     (gdb) step
     Single stepping until exit from function __mp_trap,
     which has no line number information.
     0x804c81b in __mp_getmemory()
     (gdb) step
     Single stepping until exit from function __mp_getmemory,
     which has no line number information.
     0x8049a94 in __mp_alloc()
     (gdb) step
     Single stepping until exit from function __mp_alloc,
     which has no line number information.
     strtoupper(s=0x80f0be0 "/*") at test1.c:43
     43          for (i = 0; i < l; i++)
     (gdb) watch *0x8071e36
     Hardware watchpoint 3: *134684214
     (gdb) continue
     Continuing.
     Hardware watchpoint 3: *134684214
     Old value = -1431655766
     New value = -1431655936
     strtoupper(s=0x80f0be0 "/*") at test1.c:46
     46          return t;
     (gdb) quit
     The program is running.  Exit anyway? (y or n) y

   After loading the program into `gdb', we need to break at `main()'
so that we can run to a point where all of the shared library symbols
have been loaded into memory(4).  We can then set another breakpoint at
`__mp_trap()' and continue until allocation 68 has been reached.

   Because the mpatrol library has not been built with debugging
information in this example we can quickly step back to the
`strtoupper()' function since `gdb' won't step through functions that
have no debugging information.  We then set a watch point on address
`0x8071e36', which is the address of the memory location that has been
causing the problems.  After continuing, the debugger stops at line 46,
but this is more likely to be line 45 since that is where a zero byte
is being written to(5).

   So, we have located the problem, which is simply a case of not
allocating enough memory to contain the copied string _and_ the
terminating zero byte.  We can also improve the `strtoupper()' function
by checking the pointer returned by `malloc()' to see if it is `NULL',
and if so simply exit with an error.  You can try running the program
with the `FAILFREQ' option to see how it would originally behave in a
low memory situation.

   The following listing shows the above modifications that we have
made to our program.  It can also be found in `tests/tutorial/test2.c'.

     23  /*
     24   * Reads the standard input file stream, converts all lowercase
     25   * characters to uppercase, and displays all non-empty lines to the
     26   * standard output file stream.
     27   */


     30  #include <stdio.h>
     31  #include <stdlib.h>
     32  #include <string.h>
     33  #include <ctype.h>
     34  #include "mpatrol.h"


     37  char *strtoupper(char *s)
     38  {
     39      char *t;
     40      size_t i, l;

     42      l = strlen(s);
     43      if ((t = (char *) malloc(l + 1)) == NULL)
     44      {
     45          fputs("strtoupper: out of memory\n", stderr);
     46          exit(EXIT_FAILURE);
     47      }
     48      for (i = 0; i < l; i++)
     49          t[i] = toupper(s[i]);
     50      t[i] = '\0';
     51      return t;
     52  }


     55  int main(void)
     56  {
     57      char *b, *s;

     59      b = (char *) malloc(BUFSIZ);
     60      while (gets(b))
     61      {
     62          s = strtoupper(b);
     63          if (*s != '\0')
     64          {
     65              puts(s);
     66              free(s);
     67          }
     68      }
     69      free(b);
     70      return EXIT_SUCCESS;
     71  }

   Leaving aside the obvious problem with `gets()' and the general
inefficiency of the algorithm, we could assume that our program works
safely now and we can release it to the outside world.  However, a user
soon reports a problem with our program steadily using more and more
memory during its execution when processing very large files.

   This is generally attributable to a memory leak and so we can use the
`SHOWUNFREED' option to try to detect where the memory leak is coming
from.  Following is some example output from the mpatrol log file when
our program is run and is given a relatively small text file as input.

     unfreed allocations: 10 (185 bytes)
         0x08062000 (176 bytes) {malloc:1:0} [-|-|-]
             0x400B681B __new_fopen+27
             0x0804F24E __mp_openlogfile+70
             0x080497B5 __mp_init+109
             0x08049973 __mp_alloc+31
             0x0804962E main+34 at test2.c:59
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x08067FF4 (1 byte) {malloc:83:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x08067FF8 (1 byte) {malloc:89:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x08067FFC (1 byte) {malloc:90:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x0808B304 (1 byte) {malloc:95:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x0808B308 (1 byte) {malloc:96:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x0808B30C (1 byte) {malloc:101:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x0808B310 (1 byte) {malloc:113:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x0808B314 (1 byte) {malloc:114:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

         0x0808B318 (1 byte) {malloc:118:0} [strtoupper|test2.c|43]
             0x08049593 strtoupper+51 at test2.c:43
             0x08049651 main+69 at test2.c:62
             0x4007C9CB __libc_start_main+255
             0x080494D1 _start+33

   We can discount the first entry since that is obviously coming from
when the mpatrol library first initialises itself.  However, all of the
other entries appear to be coming from line 43 within `strtoupper()'
and appear to be only 1 byte in length.  At that point in the code, the
only possible reason for allocating 1 byte is when the string is empty
and so that must mean that we are not freeing memory that contains
empty strings.  Looking at line 66 we can see that `free()' is only
ever called for non-empty strings and therefore if we move the call to
`free()' outside the test for an empty string we will fix the memory
leak.  The file `tests/tutorial/test3.c' contains the source for the
final program.

   Note that we can come to the same conclusion as above in a much
quicker manner by using the `LEAKTABLE' option.  The following is
written to the mpatrol log file when we use that option on the same
program (note that the internal memory allocation has not automatically
been added to the leak table):

     top 1 unfreed memory entry in leak table:

            bytes   count  location
         --------  ------  --------
                9       9  test2.c line 43
                9       9  total

   ---------- Footnotes ----------

   (1) On UNIX systems with dynamic linking it might also be possible
to run the program under the `mpatrol' command with its `--dynamic'
option without having to recompile or relink, but compiling and linking
with the mpatrol library is a more generic solution across different
platforms.

   (2) This is not strictly necessary on UNIX and Windows platforms
(and AmigaOS when using `gcc'), but it does give us more debugging
information.

   (3) Note that the start address of the allocation has changed
slightly since we added padding around it with the `OFLOWSIZE' option.

   (4) This is really only necessary when the mpatrol library has been
built as a shared library.

   (5) This is not necessarily the fault of the debugger or the
debugging information generated by the compiler since on most platforms
such watch points can only be caught after they occur, hence most
debuggers show the next statement to be executed rather than the current
one.


File: mpatrol.info,  Node: Functions,  Next: Environment,  Prev: Tutorial,  Up: Top

Appendix A Functions
********************

The mpatrol library contains implementations of dynamic memory
allocation functions for C and C++ suitable for tracing and debugging.
The library is intended to be used without requiring any changes to
existing user source code except the inclusion of the `mpatrol.h'
header file, although additional functions are supplied for extra
tracing and control.  Note that the current version of the mpatrol
library is contained in the `MPATROL_VERSION' preprocessor macro.

   All of the function definitions in `mpatrol.h' can be disabled by
defining the `NDEBUG' preprocessor macro, which is the same macro used
to control the behaviour of the `assert()' function.  If `NDEBUG' is
defined then no macro redefinition of functions will take place and all
special mpatrol library functions will evaluate to empty statements.
The `mpalloc.h' header file will also be included in this case.  It is
intended that the `NDEBUG' preprocessor macro be defined in release
builds.

   The `MP_MALLOC()' family of functions that are defined in `mpalloc.h'
are also defined in `mpatrol.h' when `NDEBUG' is not defined.  The
mpatrol versions of these functions contain more debugging information
than the mpalloc versions do, but they do not call the allocation
failure handler when no more memory is available (they cause the
`OUTMEM' error message to be given instead).

* Menu:

* Functions 1::                 C dynamic memory allocation functions.
* Functions 2::                 C dynamic memory extension functions.
* Functions 3::                 C dynamic memory alternative functions.
* Functions 4::                 C++ dynamic memory allocation functions.
* Functions 5::                 C memory operation functions.
* Functions 6::                 mpatrol library functions.


File: mpatrol.info,  Node: Functions 1,  Next: Functions 2,  Up: Functions

A.1 C dynamic memory allocation functions
=========================================

The following 19 functions are available as replacements for existing C
library functions.  To use these you must include `mpatrol.h' before
all other header files, although on UNIX and Windows platforms (and
AmigaOS when using `gcc') they will be used anyway, albeit with
slightly less tracing information.  If `alloca()' is being used and
`alloca.h' is included then `mpatrol.h' must appear before `alloca.h'
otherwise the debugging version of `alloca()' will not be used.

`void *malloc(size_t size)'
     Allocates SIZE uninitialised bytes from the heap and returns a
     pointer to the first byte of the allocation.  The pointer returned
     will be suitably aligned for casting to any type and can be used
     to store data of up to SIZE bytes in length.  If SIZE is `0' then
     the memory allocated will be implicitly rounded up to `1' byte.
     If there is not enough space in the heap then the `NULL' pointer
     will be returned and `errno' will be set to `ENOMEM'.  The
     allocated memory must be deallocated with `free()' or reallocated
     with `realloc()'.

`void *calloc(size_t nelem, size_t size)'
     Allocates NELEM elements of SIZE zero-initialised bytes from the
     heap and returns a pointer to the first byte of the allocation.
     The pointer returned will be suitably aligned for casting to any
     type and can be used to store data of up to `nelem * size' bytes
     in length.  If `nelem * size' is `0' then the amount of memory
     allocated will be implicitly rounded up to `1' byte.  If there is
     not enough space in the heap then the `NULL' pointer will be
     returned and `errno' will be set to `ENOMEM'.  The allocated
     memory must be deallocated with `free()' or reallocated with
     `realloc()'.

`void *memalign(size_t align, size_t size)'
     Allocates SIZE uninitialised bytes from the heap and returns a
     pointer to the first byte of the allocation.  The pointer returned
     will be aligned to ALIGN bytes and can be used to store data of up
     to SIZE bytes in length.  If ALIGN is zero then the default system
     alignment will be used.  If ALIGN is not a power of two then it
     will be rounded up to the nearest power of two.  If ALIGN is
     greater than the system page size then it will be truncated to
     that value.  If SIZE is `0' then the memory allocated will be
     implicitly rounded up to `1' byte.  If there is not enough space in
     the heap then the `NULL' pointer will be returned and `errno' will
     be set to `ENOMEM'.  The allocated memory must be deallocated with
     `free()' or reallocated with `realloc()', although the latter will
     not guarantee the preservation of alignment.

`void *valloc(size_t size)'
     Allocates SIZE uninitialised bytes from the heap and returns a
     pointer to the first byte of the allocation.  The pointer returned
     will be aligned to the system page size and can be used to store
     data of up to SIZE bytes in length.  If SIZE is `0' then the
     memory allocated will be implicitly rounded up to `1' byte.  If
     there is not enough space in the heap then the `NULL' pointer will
     be returned and `errno' will be set to `ENOMEM'.  The allocated
     memory must be deallocated with `free()' or reallocated with
     `realloc()', although the latter will not guarantee the
     preservation of alignment.

`void *pvalloc(size_t size)'
     Allocates SIZE uninitialised bytes from the heap and returns a
     pointer to the first byte of the allocation.  The pointer returned
     will be aligned to the system page size and can be used to store
     data of up to SIZE bytes in length.  If SIZE is `0' then the
     memory allocated will be implicitly rounded up to `1' page,
     otherwise SIZE will be implicitly rounded up to a multiple of the
     system page size.  If there is not enough space in the heap then
     the `NULL' pointer will be returned and `errno' will be set to
     `ENOMEM'.  The allocated memory must be deallocated with `free()'
     or reallocated with `realloc()', although the latter will not
     guarantee the preservation of alignment.

`void *alloca(size_t size)'
     Allocates SIZE temporary uninitialised bytes from the heap and
     returns a pointer to the first byte of the allocation.  The
     pointer returned will be suitably aligned for casting to any type
     and can be used to store data of up to SIZE bytes in length.  If
     SIZE is `0' then the memory allocated will be implicitly rounded
     up to `1' byte.  If there is not enough space in the heap then the
     program will be terminated and the `OUTMEM' error will be given.
     The `alloca()' function normally allocates its memory from the
     stack, with the result that all such allocations will be freed
     when the function returns.  This version of `alloca()' allocates
     its memory from the heap in order to provide better debugging, but
     the allocations may not necessarily be freed immediately when the
     function returns.  The allocated memory can be deallocated
     explicitly with `dealloca()', but may not be reallocated or
     deallocated in any other way.  This function is available for
     backwards compatibility with older C source code and should not be
     used in new code.

`char *strdup(const char *str)'
     Allocates exactly enough memory from the heap to duplicate STR
     (including the terminating nul character) and returns a pointer to
     the first byte of the allocation after copying STR to the
     newly-allocated memory.  The pointer returned will have no
     alignment constraints and can be used to store character data up
     to the length of STR.  If STR is `NULL' then an error will be
     given and the `NULL' pointer will be returned.  If there is not
     enough space in the heap then the `NULL' pointer will be returned
     and `errno' will be set to `ENOMEM'.  The allocated memory must be
     deallocated with `free()' or reallocated with `realloc()'.

`char *strndup(const char *str, size_t size)'
     Allocates exactly enough memory from the heap to duplicate STR
     (including the terminating nul character) and returns a pointer to
     the first byte of the allocation after copying STR to the
     newly-allocated memory.  The pointer returned will have no
     alignment constraints and can be used to store character data up
     to the length of STR.  If STR is `NULL' and SIZE is non-zero then
     an error will be given and the `NULL' pointer will be returned.
     If the length of STR is greater than SIZE then only SIZE
     characters will be allocated and copied, with one additional byte
     for the nul character.  If there is not enough space in the heap
     then the `NULL' pointer will be returned and `errno' will be set to
     `ENOMEM'.  The allocated memory must be deallocated with `free()'
     or reallocated with `realloc()'.  This function is available for
     backwards compatibility with older C libraries and should not be
     used in new code.

`char *strsave(const char *str)'
     Allocates exactly enough memory from the heap to duplicate STR
     (including the terminating nul character) and returns a pointer to
     the first byte of the allocation after copying STR to the
     newly-allocated memory.  The pointer returned will have no
     alignment constraints and can be used to store character data up
     to the length of STR.  If STR is `NULL' then an error will be
     given and the `NULL' pointer will be returned.  If there is not
     enough space in the heap then the `NULL' pointer will be returned
     and `errno' will be set to `ENOMEM'.  The allocated memory must be
     deallocated with `free()' or reallocated with `realloc()'.  This
     function is available for backwards compatibility with older C
     libraries and should not be used in new code.

`char *strnsave(const char *str, size_t size)'
     Allocates exactly enough memory from the heap to duplicate STR
     (including the terminating nul character) and returns a pointer to
     the first byte of the allocation after copying STR to the
     newly-allocated memory.  The pointer returned will have no
     alignment constraints and can be used to store character data up
     to the length of STR.  If STR is `NULL' and SIZE is non-zero then
     an error will be given and the `NULL' pointer will be returned.
     If the length of STR is greater than SIZE then only SIZE
     characters will be allocated and copied, with one additional byte
     for the nul character.  If there is not enough space in the heap
     then the `NULL' pointer will be returned and `errno' will be set to
     `ENOMEM'.  The allocated memory must be deallocated with `free()'
     or reallocated with `realloc()'.  This function is available for
     backwards compatibility with older C libraries and should not be
     used in new code.

`char *strdupa(const char *str)'
     Allocates exactly enough temporary memory from the heap to
     duplicate STR (including the terminating nul character) and
     returns a pointer to the first byte of the allocation after
     copying STR to the newly-allocated memory.  The pointer returned
     will have no alignment constraints and can be used to store
     character data up to the length of STR.  If STR is `NULL' then an
     error will be given and the `NULL' pointer will be returned.  If
     there is not enough space in the heap then the program will be
     terminated and the `OUTMEM' error will be given.  The `strdupa()'
     function normally allocates its memory from the stack, with the
     result that all such allocations will be freed when the function
     returns.  This version of `strdupa()' allocates its memory from
     the heap in order to provide better debugging, but the allocations
     may not necessarily be freed immediately when the function returns.
     The allocated memory can be deallocated explicitly with
     `dealloca()', but may not be reallocated or deallocated in any
     other way.  This function is available for backwards compatibility
     with older C source code and should not be used in new code.

`char *strndupa(const char *str, size_t size)'
     Allocates exactly enough temporary memory from the heap to
     duplicate STR (including the terminating nul character) and
     returns a pointer to the first byte of the allocation after
     copying STR to the newly-allocated memory.  The pointer returned
     will have no alignment constraints and can be used to store
     character data up to the length of STR.  If STR is `NULL' and SIZE
     is non-zero then an error will be given and the `NULL' pointer
     will be returned.  If the length of STR is greater than SIZE then
     only SIZE characters will be allocated and copied, with one
     additional byte for the nul character.  If there is not enough
     space in the heap then the program will be terminated and the
     `OUTMEM' error will be given.  The `strndupa()' function normally
     allocates its memory from the stack, with the result that all such
     allocations will be freed when the function returns.  This version
     of `strndupa()' allocates its memory from the heap in order to
     provide better debugging, but the allocations may not necessarily
     be freed immediately when the function returns.  The allocated
     memory can be deallocated explicitly with `dealloca()', but may
     not be reallocated or deallocated in any other way.  This function
     is available for backwards compatibility with older C source code
     and should not be used in new code.

`void *realloc(void *ptr, size_t size)'
     Resizes the memory allocation beginning at PTR to SIZE bytes and
     returns a pointer to the first byte of the new allocation after
     copying PTR to the newly-allocated memory, which will be truncated
     if SIZE is smaller than the original allocation.  The pointer
     returned will be suitably aligned for casting to any type and can
     be used to store data of up to SIZE bytes in length.  If PTR is
     `NULL' then the call will be equivalent to `malloc()'.  If SIZE is
     `0' then the existing memory allocation will be freed and the
     `NULL' pointer will be returned.  If SIZE is greater than the
     original allocation then the extra space will be filled with
     uninitialised bytes.  If there is not enough space in the heap
     then the `NULL' pointer will be returned and `errno' will be set to
     `ENOMEM'.  The allocated memory must be deallocated with `free()'
     and can be reallocated again with `realloc()'.

`void *reallocf(void *ptr, size_t size)'
     Resizes the memory allocation beginning at PTR to SIZE bytes and
     returns a pointer to the first byte of the new allocation after
     copying PTR to the newly-allocated memory, which will be truncated
     if SIZE is smaller than the original allocation.  The pointer
     returned will be suitably aligned for casting to any type and can
     be used to store data of up to SIZE bytes in length.  If PTR is
     `NULL' then the call will be equivalent to `malloc()'.  If SIZE is
     `0' then the existing memory allocation will be freed and the
     `NULL' pointer will be returned.  If SIZE is greater than the
     original allocation then the extra space will be filled with
     uninitialised bytes.  If there is not enough space in the heap
     then the `NULL' pointer will be returned, the original allocation
     will be freed and `errno' will be set to `ENOMEM'.  The allocated
     memory must be deallocated with `free()' and can be reallocated
     again with `realloc()'.  This function is available for backwards
     compatibility with older C libraries and should not be used in new
     code.

`void *recalloc(void *ptr, size_t nelem, size_t size)'
     Resizes the memory allocation beginning at PTR to NELEM elements of
     SIZE bytes and returns a pointer to the first byte of the new
     allocation after copying PTR to the newly-allocated memory, which
     will be truncated if `nelem * size' is smaller than the original
     allocation.  The pointer returned will be suitably aligned for
     casting to any type and can be used to store data of up to `nelem
     * size' bytes in length.  If PTR is `NULL' then the call will be
     equivalent to `calloc()'.  If `nelem * size' is `0' then the
     existing memory allocation will be freed and the `NULL' pointer
     will be returned.  If `nelem * size' is greater than the original
     allocation then the extra space will be filled with
     zero-initialised bytes.  If there is not enough space in the heap
     then the `NULL' pointer will be returned and `errno' will be set to
     `ENOMEM'.  The allocated memory must be deallocated with `free()'
     and can be reallocated again with `realloc()'.  This function is
     available for backwards compatibility with older C libraries and
     `calloc()' and should not be used in new code.

`void *expand(void *ptr, size_t size)'
     Attempts to resize the memory allocation beginning at PTR to SIZE
     bytes and either returns PTR if there was enough space to resize
     it, or `NULL' if the block could not be resized for a particular
     reason.  If PTR is `NULL' then the call will be equivalent to
     `malloc()'.  If SIZE is `0' then the existing memory allocation
     will be freed and the `NULL' pointer will be returned.  If SIZE is
     greater than the original allocation then the extra space will be
     filled with uninitialised bytes and if SIZE is less than the
     original allocation then the memory block will be truncated.  If
     there is not enough space in the heap then the `NULL' pointer will
     be returned and `errno' will be set to `ENOMEM'.  The allocated
     memory must be deallocated with `free()' and can be reallocated
     again with `realloc()'.  This function is available for backwards
     compatibility with older C libraries and should not be used in new
     code.

`void free(void *ptr)'
     Frees the memory allocation beginning at PTR so the memory can be
     reused by another call to allocate memory.  If PTR is `NULL' then
     no memory will be freed.  All of the previous contents will be
     destroyed.

`void cfree(void *ptr, size_t nelem, size_t size)'
     Frees the memory allocation beginning at PTR so the memory can be
     reused by another call to allocate memory.  If PTR is `NULL' then
     no memory will be freed.  All of the previous contents will be
     destroyed.  The NELEM and SIZE parameters are ignored in this
     implementation.  This function is available for backwards
     compatibility with older C libraries and `calloc()' and should not
     be used in new code.

`void dealloca(void *ptr)'
     Explicitly frees the temporary memory allocation beginning at PTR
     so the memory can be reused by another call to allocate memory.
     If PTR is `NULL' then no memory will be freed.  All of the
     previous contents will be destroyed.  This function can only be
     used to free memory that was allocated with the `alloca()',
     `strdupa()' and `strndupa()' functions, but is only really
     required if the mpatrol library does not automatically free such
     memory allocations when the allocating function returns.  This
     function is mpatrol-specific and should not be used in release
     code.


File: mpatrol.info,  Node: Functions 2,  Next: Functions 3,  Prev: Functions 1,  Up: Functions

A.2 C dynamic memory extension functions
========================================

The following 5 functions are available as replacements for existing C
library extension functions that always abort and never return `NULL'
if there is insufficient memory to fulfil a request.  To use these you
must include `mpatrol.h' before all other header files, although on
UNIX and Windows platforms (and AmigaOS when using `gcc') they will be
used anyway, albeit with slightly less tracing information.

`void *xmalloc(size_t size)'
     Allocates SIZE uninitialised bytes from the heap and returns a
     pointer to the first byte of the allocation.  The pointer returned
     will be suitably aligned for casting to any type and can be used
     to store data of up to SIZE bytes in length.  If SIZE is `0' then
     the memory allocated will be implicitly rounded up to `1' byte.
     If there is not enough space in the heap then the program will be
     terminated and the `OUTMEM' error will be given.  The allocated
     memory must be deallocated with `xfree()' or reallocated with
     `xrealloc()'.

`void *xcalloc(size_t nelem, size_t size)'
     Allocates NELEM elements of SIZE zero-initialised bytes from the
     heap and returns a pointer to the first byte of the allocation.
     The pointer returned will be suitably aligned for casting to any
     type and can be used to store data of up to `nelem * size' bytes
     in length.  If `nelem * size' is `0' then the amount of memory
     allocated will be implicitly rounded up to `1' byte.  If there is
     not enough space in the heap then the program will be terminated
     and the `OUTMEM' error will be given.  The allocated memory must
     be deallocated with `xfree()' or reallocated with `xrealloc()'.

`char *xstrdup(const char *str)'
     Allocates exactly enough memory from the heap to duplicate STR
     (including the terminating nul character) and returns a pointer to
     the first byte of the allocation after copying STR to the
     newly-allocated memory.  The pointer returned will have no
     alignment constraints and can be used to store character data up
     to the length of STR.  If STR is `NULL' then an error will be
     given and the `NULL' pointer will be returned.  If there is not
     enough space in the heap then the program will be terminated and
     the `OUTMEM' error will be given.  The allocated memory must be
     deallocated with `xfree()' or reallocated with `xrealloc()'.

`void *xrealloc(void *ptr, size_t size)'
     Resizes the memory allocation beginning at PTR to SIZE bytes and
     returns a pointer to the first byte of the new allocation after
     copying PTR to the newly-allocated memory, which will be truncated
     if SIZE is smaller than the original allocation.  The pointer
     returned will be suitably aligned for casting to any type and can
     be used to store data of up to SIZE bytes in length.  If PTR is
     `NULL' then the call will be equivalent to `xmalloc()'.  If SIZE
     is `0' then it will be implicitly rounded up to `1'.  If SIZE is
     greater than the original allocation then the extra space will be
     filled with uninitialised bytes.  If there is not enough space in
     the heap then the program will be terminated and the `OUTMEM'
     error will be given.  The allocated memory must be deallocated
     with `xfree()' and can be reallocated again with `xrealloc()'.

`void xfree(void *ptr)'
     Frees the memory allocation beginning at PTR so the memory can be
     reused by another call to allocate memory.  If PTR is `NULL' then
     no memory will be freed.  All of the previous contents will be
     destroyed.


File: mpatrol.info,  Node: Functions 3,  Next: Functions 4,  Prev: Functions 2,  Up: Functions

A.3 C dynamic memory alternative functions
==========================================

The following 6 functions are provided as convenient alternatives to
the ANSI C dynamic memory allocation functions (although `strdup()' is
not strictly an ANSI C function).  They are implemented as preprocessor
macro functions which may evaluate their arguments more than once, so
extra care should be taken to avoid passing arguments with
side-effects.  None of the functions return `NULL' if no memory is
available and instead abort the program with a useful error message
indicating where the call to allocate memory came from and what was
being allocated.  To use these you should include the `mpatrol.h' or
`mpalloc.h' header files.

`void *MP_MALLOC(void *ptr, size_t count, typename type)'
     Allocates COUNT uninitialised items of type TYPE from the heap,
     sets PTR to the result and returns a suitably-cast pointer to the
     first item of the allocation.  The pointer returned will be
     suitably aligned for holding items of type TYPE.  If COUNT is `0'
     then it will be implicitly rounded up to `1'.  If there is not
     enough space in the heap then the program will be aborted after
     calling the allocation failure handler, which by default writes an
     appropriate error message to the standard error file stream.  The
     allocated memory in PTR must be deallocated with `MP_FREE()' or
     reallocated with `MP_REALLOC()'.

`void *MP_CALLOC(void *ptr, size_t count, typename type)'
     Allocates COUNT zero-initialised items of type TYPE from the heap,
     sets PTR to the result and returns a suitably-cast pointer to the
     first item of the allocation.  The pointer returned will be
     suitably aligned for holding items of type TYPE.  If COUNT is `0'
     then it will be implicitly rounded up to `1'.  If there is not
     enough space in the heap then the program will be aborted after
     calling the allocation failure handler, which by default writes an
     appropriate error message to the standard error file stream.  The
     allocated memory in PTR must be deallocated with `MP_FREE()' or
     reallocated with `MP_REALLOC()'.

`char *MP_STRDUP(char *ptr, const char *str)'
     Allocates exactly enough memory from the heap to duplicate STR
     (including the terminating nul character), sets PTR to the result
     and returns a suitably-cast pointer to the first byte of the
     allocation after copying STR to the newly-allocated memory.  The
     pointer returned will have no alignment constraints and can be
     used to store character data up to the length of STR.  If there is
     not enough space in the heap then the program will be aborted
     after calling the allocation failure handler, which by default
     writes an appropriate error message to the standard error file
     stream.  The allocated memory in PTR must be deallocated with
     `MP_FREE()' or reallocated with `MP_REALLOC()'.

`void *MP_REALLOC(void *ptr, size_t count, typename type)'
     Resizes the memory allocation beginning at PTR to COUNT items of
     type TYPE and returns a suitably-cast pointer to the first item of
     the new allocation after copying PTR to the newly-allocated
     memory, which will be truncated if COUNT is smaller than the
     original number of items.  The pointer returned will be suitably
     aligned for holding items of type TYPE.  If PTR is `NULL' then the
     call will be equivalent to `MP_MALLOC()'.  If COUNT is `0' then it
     will be implicitly rounded up to `1'.  If COUNT is greater than
     the original number of items then the extra space will be filled
     with uninitialised bytes.  If there is not enough space in the
     heap then the program will be aborted after calling the allocation
     failure handler, which by default writes an appropriate error
     message to the standard error file stream.  The allocated memory
     must be deallocated with `MP_FREE()' and can be reallocated again
     with `MP_REALLOC()'.

`void MP_FREE(void *ptr)'
     Frees the memory allocation beginning at PTR so the memory can be
     reused by another call to allocate memory, and sets PTR to `NULL'
     after freeing the memory.  If PTR is `NULL' then no memory will be
     freed.

`__mp_failhandler MP_FAILURE(__mp_failhandler func)'
     Installs an allocation failure handler specifically for use with
     `MP_MALLOC()', `MP_CALLOC()', `MP_STRDUP()' and `MP_REALLOC()' and
     returns a pointer to the previously installed handler, normally
     the default handler if no handler had been previously installed.
     This will be called by the above functions when there is not
     enough space in the heap for them to satisfy their allocation
     request.  The default allocation failure handler will terminate
     the program after writing an error message to the standard error
     file stream indicating where the original allocation request took
     place and what was being allocated.


File: mpatrol.info,  Node: Functions 4,  Next: Functions 5,  Prev: Functions 3,  Up: Functions

A.4 C++ dynamic memory allocation functions
===========================================

The following 5 functions are available as replacements for existing
C++ library functions, but the replacements in `mpatrol.h' will only be
used if the `MP_NOCPLUSPLUS' preprocessor macro is not defined.  The
replacement operators make use of the preprocessor in order to obtain
source-level information.  If this causes problems then you should
define the `MP_NONEWDELETE' preprocessor macro and use the `MP_NEW',
`MP_NEW_NOTHROW' and `MP_DELETE' macros instead of `new' and `delete'
directly.  To use these C++ features you must include `mpatrol.h'
before all other header files, although on UNIX and Windows platforms
(and AmigaOS when using `gcc') they will be used anyway, albeit with
slightly less tracing information.

`void *operator new(size_t size)'
     Allocates SIZE uninitialised bytes from the heap and returns a
     pointer to the first byte of the allocation.  The pointer returned
     will be suitably aligned for casting to any type and can be used
     to store data of up to SIZE bytes in length.  If SIZE is `0' then
     the memory allocated will be implicitly rounded up to `1' byte.
     If there is not enough space in the heap then either the
     `std::bad_alloc' exception will be thrown or the null pointer will
     be returned and `errno' will be set to `ENOMEM' -- the behaviour
     depends on whether the _nothrow_ version of the operator is used.
     The allocated memory must be deallocated with `operator delete'.

`void *operator new[](size_t size)'
     Allocates SIZE uninitialised bytes from the heap and returns a
     pointer to the first byte of the allocation.  The pointer returned
     will be suitably aligned for casting to any type and can be used
     to store data of up to SIZE bytes in length.  If SIZE is `0' then
     the memory allocated will be implicitly rounded up to `1' byte.
     If there is not enough space in the heap then either the
     `std::bad_alloc' exception will be thrown or the null pointer will
     be returned and `errno' will be set to `ENOMEM' -- the behaviour
     depends on whether the _nothrow_ version of the operator is used.
     The allocated memory must be deallocated with `operator delete[]'.

`void operator delete(void *ptr)'
     Frees the memory allocation beginning at PTR so the memory can be
     reused by another call to allocate memory.  If PTR is `NULL' then
     no memory will be freed.  All of the previous contents will be
     destroyed.  This function must only be used with memory allocated
     by `operator new'.

`void operator delete[](void *ptr)'
     Frees the memory allocation beginning at PTR so the memory can be
     reused by another call to allocate memory.  If PTR is `NULL' then
     no memory will be freed.  All of the previous contents will be
     destroyed.  This function must only be used with memory allocated
     by `operator new[]'.

`std::new_handler std::set_new_handler(std::new_handler func)'
     Installs a low-memory handler specifically for use with `operator
     new' and `operator new[]' and returns a pointer to the previously
     installed handler, or the null pointer if no handler had been
     previously installed.  This will be called repeatedly by both
     functions when they would normally return `NULL', and this loop
     will continue until they manage to allocate the requested space.
     Note that this function is equivalent to `__mp_nomemory()' and
     will replace the handler installed by that function.


File: mpatrol.info,  Node: Functions 5,  Next: Functions 6,  Prev: Functions 4,  Up: Functions

A.5 C memory operation functions
================================

The following 10 functions are available as replacements for existing C
library memory operation functions.  To use these you must include
`mpatrol.h' before all other header files, although on UNIX and Windows
platforms (and AmigaOS when using `gcc') they will be used anyway,
albeit with slightly less tracing information.

`void *memset(void *ptr, int byte, size_t size)'
     Writes SIZE bytes of value BYTE to the memory location beginning at
     PTR and returns PTR.  If SIZE is `0' then no bytes will be
     written.  If the operation would affect an existing memory
     allocation in the heap but would straddle that allocation's
     boundaries then an error message will be generated in the log file
     and no bytes will be written.

`void bzero(void *ptr, size_t size)'
     Writes SIZE zero bytes to the memory location beginning at PTR.  If
     SIZE is `0' then no bytes will be written.  If the operation would
     affect an existing memory allocation in the heap but would
     straddle that allocation's boundaries then an error message will
     be generated in the log file and no bytes will be written.  This
     function is available for backwards compatibility with older C
     libraries and should not be used in new code.

`void *memccpy(void *dest, const void *src, int byte, size_t size)'
     Copies SIZE bytes from SRC to DEST and returns `NULL', or copies
     the number of bytes up to and including the first occurrence of
     BYTE if BYTE exists within the specified range and returns a
     pointer to the first byte after BYTE.  If SIZE is `0' or SRC is
     the same as DEST then no bytes will be copied.  The source and
     destination ranges should not overlap, otherwise a warning will be
     written to the log file.  If the operation would affect an
     existing memory allocation in the heap but would straddle that
     allocation's boundaries then an error message will be generated in
     the log file and no bytes will be copied.

`void *memcpy(void *dest, const void *src, size_t size)'
     Copies SIZE bytes from SRC to DEST and returns DEST.  If SIZE is
     `0' or SRC is the same as DEST then no bytes will be copied.  The
     source and destination ranges should not overlap, otherwise a
     warning will be written to the log file.  If the operation would
     affect an existing memory allocation in the heap but would
     straddle that allocation's boundaries then an error message will
     be generated in the log file and no bytes will be copied.

`void *memmove(void *dest, const void *src, size_t size)'
     Copies SIZE bytes from SRC to DEST and returns DEST.  If SIZE is
     `0' or SRC is the same as DEST then no bytes will be copied.  If
     the operation would affect an existing memory allocation in the
     heap but would straddle that allocation's boundaries then an error
     message will be generated in the log file and no bytes will be
     copied.

`void bcopy(const void *src, void *dest, size_t size)'
     Copies SIZE bytes from SRC to DEST.  If SIZE is `0' or SRC is the
     same as DEST then no bytes will be copied.  If the operation would
     affect an existing memory allocation in the heap but would
     straddle that allocation's boundaries then an error message will
     be generated in the log file and no bytes will be copied.  This
     function is available for backwards compatibility with older C
     libraries and should not be used in new code.

`int memcmp(const void *ptr1, const void *ptr2, size_t size)'
     Compares SIZE bytes from PTR1 and PTR2 and returns `0' if all of
     the bytes are identical, or returns the byte difference of the
     first differing bytes.  If SIZE is `0' or PTR1 is the same as PTR2
     then no bytes will be compared.  If the operation would read from
     an existing memory allocation in the heap but would straddle that
     allocation's boundaries then an error message will be generated in
     the log file and no bytes will be compared.

`int bcmp(const void *ptr1, const void *ptr2, size_t size)'
     Compares SIZE bytes from PTR1 and PTR2 and returns `0' if all of
     the bytes are identical, or returns the byte difference of the
     first differing bytes.  If SIZE is `0' or PTR1 is the same as PTR2
     then no bytes will be compared.  If the operation would read from
     an existing memory allocation in the heap but would straddle that
     allocation's boundaries then an error message will be generated in
     the log file and no bytes will be compared.  This function is
     available for backwards compatibility with older C libraries and
     should not be used in new code.

`void *memchr(const void *ptr, int byte, size_t size)'
     Searches up to SIZE bytes in PTR for the first occurrence of BYTE
     and returns a pointer to it or `NULL' if no such byte occurs.  If
     SIZE is `0' then no bytes will be searched.  If the operation
     would affect an existing memory allocation in the heap but would
     straddle that allocation's boundaries then an error message will
     be generated in the log file and no bytes will be searched.

`void *memmem(const void *ptr1, size_t size1, const void *ptr2, size_t size2)'
     Searches up to SIZE1 bytes in PTR1 for the first occurrence of
     PTR2 (which is exactly SIZE2 bytes in length) and returns a pointer
     to it or `NULL' if no such sequence of bytes occur.  If SIZE1 or
     SIZE2 is `0' then no bytes will be searched.  If the operation
     would affect an existing memory allocation in the heap but would
     straddle that allocation's boundaries then an error message will
     be generated in the log file and no bytes will be searched.


File: mpatrol.info,  Node: Functions 6,  Prev: Functions 5,  Up: Functions

A.6 mpatrol library functions
=============================

The following 42 functions are available as support routines for
additional control and tracing in the mpatrol library.  Although they
are documented here as being prefixed by `__mp_', their equivalent
functions that are prefixed by `mpatrol_' are also defined as aliases
in the `mpatrol.h' header file.  To use these you should include the
`mpatrol.h' header file.

`int __mp_atexit(void (*func)(void))'
     Installs a function to be called when the mpatrol library
     terminates.  Up to 32 such functions can be registered and will be
     called in reverse order of registration.  Returns `1' on success
     or `0' if FUNC could not be registered.

`unsigned long __mp_setoption(long opt, unsigned long val)'
     Sets the value of an mpatrol option after the library has been
     initialised.  Options that require values are listed in
     `mpatrol.h' prefixed with `MP_OPT_*'.  The OPT argument should be
     set to one of these macros, and the VAL argument should be set to
     the option value, cast to an unsigned integer.  The return value
     will be `0' on success and `1' on failure.  Options that are flags
     are listed in `mpatrol.h' prefixed with `MP_FLG_*'.  Multiple
     flags can be set or unset at once using the `MP_OPT_SETFLAGS' and
     `MP_OPT_UNSETFLAGS' options respectively, with the necessary flags
     specified in VAL.  The return value will be `0' on success and a
     combination of all of the flags that could not be set or unset on
     failure.

`int __mp_getoption(long opt, unsigned long *val)'
     Gets the value of an mpatrol option after the library has been
     initialised.  If OPT is a valid option listed in `mpatrol.h' then
     `1' will be returned and the associated value will be returned in
     VAL and cast to an unsigned integer, otherwise `0' will be
     returned.  If OPT is `MP_OPT_SETFLAGS' then all of the mpatrol
     library flags that are set will be returned in VAL.  If OPT is
     `MP_OPT_UNSETFLAGS' then all of the mpatrol library flags that are
     not set will be returned in VAL.

`unsigned long __mp_libversion(void)'
     Returns the version number of the mpatrol library.  This can be
     useful for verifying that the version of the mpatrol library that
     a program is linked with is the one expected at compile-time.

`const char *__mp_strerror(__mp_errortype err)'
     Returns the error message corresponding to the error code ERR or
     `NULL' if no such error code exists.  The most recent error code
     recorded by the mpatrol library can be obtained by examining
     `__mp_errno'.

`const char *__mp_function(__mp_alloctype func)'
     Returns the name of the function corresponding to the allocation
     type FUNC or `NULL' if no such allocation type exists.

`int __mp_setuser(const void *ptr, const void *data)'
     Sets the user data for the memory allocation containing PTR.  The
     contents of DATA are entirely application-specific as user data
     will never be examined by the mpatrol library.  Such data is
     associated with a memory allocation for its entire lifetime unless
     overridden by a subsequent call to `__mp_setuser()'.  As such, the
     user data must be valid for the entire lifetime of the memory
     allocation, perhaps even after the allocation has been freed if
     the `NOFREE' option is being used.  This function returns `1' if
     there is an allocated memory block containing PTR, and `0'
     otherwise.

`int __mp_setmark(const void *ptr)'
     Sets the marked flag for the memory allocation containing PTR,
     indicating that the memory allocation cannot be freed (but can be
     reallocated) and thus will not be listed as a memory leak.  This
     function returns `1' if there is an allocated memory block
     containing PTR, and `0' otherwise.  Note that a memory allocation
     made by `alloca()', `strdupa()' or `strndupa()' may not be marked.

`int __mp_info(const void *ptr, __mp_allocinfo *info)'
     Obtains information about a specific memory allocation by placing
     statistics about PTR in INFO.  If PTR does not belong to a
     previously allocated memory allocation or free memory block then
     `0' will be returned, otherwise `1' will be returned and INFO will
     contain the following information (note that a free memory block
     will only contain the `block' and `size' fields and can be
     identified by not having the `allocated' flag set):

     _Field_       _Description_
     `block'       Pointer to first byte of allocation.
     `size'        Size of allocation in bytes.
     `type'        Type of function which allocated memory.
     `alloc'       Allocation index.
     `realloc'     Number of times reallocated.
     `thread'      Thread identifier.
     `event'       Event of last modification.
     `func'        Function in which allocation took place.
     `file'        File in which allocation took place.
     `line'        Line number at which allocation took place.
     `stack'       Pointer to function call stack.
     `typestr'     Type stored in allocation.
     `typesize'    Size of type stored in allocation.
     `userdata'    User data associated with allocation.
     `allocated'   Indicates if allocation was allocated.
     `freed'       Indicates if allocation has been freed.
     `marked'      Indicates if allocation has been marked.
     `profiled'    Indicates if allocation has been profiled.
     `traced'      Indicates if allocation has been traced.
     `internal'    Indicates if allocation is internal.

`int __mp_syminfo(const void *ptr, __mp_symbolinfo *info)'
     Obtains symbolic information about a specific code address by
     placing statistics about PTR in INFO.  If PTR does not belong to a
     function symbol then `0' will be returned, otherwise `1' will be
     returned and INFO will contain the following information:

     _Field_       _Description_
     `name'        Name of symbol.
     `object'      File containing symbol.
     `addr'        Start address of symbol.
     `size'        Size of symbol.
     `file'        Filename corresponding to address.
     `line'        Line number corresponding to address.

`const char *__mp_symbol(const void *ptr)'
     Obtains the name of a function symbol containing the code address
     specified in PTR.  If PTR does not belong to a function symbol
     then `NULL' will be returned.

`int __mp_printinfo(const void *ptr)'
     Displays information about a specific memory allocation containing
     PTR to the standard error file stream.  If PTR does not belong to
     a previously allocated memory allocation or free memory block then
     `0' will be returned, otherwise `1' will be returned.  This
     function is intended to be called from within a debugger.

`unsigned long __mp_snapshot(void)'
     Returns the current event number, effectively taking a snapshot of
     the heap.  This number can then be used in later calls to
     `__mp_iterate()'.

`size_t __mp_iterate(int (*func)(const void *, void *), void *data, unsigned long event)'
     Iterates over all of the current allocated and freed memory
     allocations, calling FUNC with the start address of every memory
     allocation that has been modified since event number EVENT.  If
     FUNC is `NULL' then `__mp_printinfo()' will be used as the
     callback function.  If EVENT is `0' then FUNC will be called with
     the start address of every memory allocation.  If FUNC returns a
     negative number then the iteration process will be stopped
     immediately.  If FUNC returns a positive number above zero then
     `__mp_iterate()' will return the number of times FUNC returned a
     non-zero number after the iteration process has stopped.  The DATA
     argument is passed directly to FUNC as its second argument and is
     not read by the mpatrol library.

`size_t __mp_iterateall(int (*func)(const void *, void *), void *data)'
     Iterates over all of the current allocated and freed memory
     allocations and any free memory blocks, calling FUNC with the
     start address of every memory allocation or free block.  If FUNC
     is `NULL' then `__mp_printinfo()' will be used as the callback
     function.  If FUNC returns a negative number then the iteration
     process will be stopped immediately.  If FUNC returns a positive
     number above zero then `__mp_iterate()' will return the number of
     times FUNC returned a non-zero number after the iteration process
     has stopped.  The DATA argument is passed directly to FUNC as its
     second argument and is not read by the mpatrol library.  Note that
     unlike `__mp_iterate()', this function will also include internal
     memory allocations made by the mpatrol library and is intended for
     walking the entire heap.

`int __mp_addallocentry(const char *file, unsigned long line, size_t size)'
     Adds an entry representing an allocation of size SIZE to the leak
     table.  The allocation will be associated with a source filename
     of FILE and a line number of LINE if the former is non-`NULL' and
     the latter is non-zero.  If FILE is non-`NULL' and LINE is `0' then
     FILE represents the name of the function that made the allocation.
     If FILE is `NULL' and LINE is non-zero then LINE represents the
     code address at which the allocation was made.  If FILE is `NULL'
     and LINE is `0' then the location of the allocation is unknown.
     Returns `1' on success and `0' if there was no more memory
     available to add another entry to the leak table.

`int __mp_addfreeentry(const char *file, unsigned long line, size_t size)'
     Adds an entry representing a deallocation of size SIZE to the leak
     table.  The deallocation will be associated with a source filename
     of FILE and a line number of LINE if the former is non-`NULL' and
     the latter is non-zero.  If FILE is non-`NULL' and LINE is `0' then
     FILE represents the name of the function that made the
     deallocation.  If FILE is `NULL' and LINE is non-zero then LINE
     represents the code address at which the deallocation was made.
     If FILE is `NULL' and LINE is `0' then the location of the
     deallocation is unknown.  Returns `1' on success and `0' if there
     was no existing allocation from the same location in the leak
     table.

`void __mp_clearleaktable(void)'
     Deletes all of the existing entries in the leak table, making it
     empty.  This will also affect the behaviour of the `LEAKTABLE'
     option since that option will then only be able to show a summary
     of the entries in the leak table that were collected after the
     last call to this function rather than from the start of program
     execution.

`int __mp_startleaktable(void)'
     Starts the automatic logging of all memory allocations,
     reallocations and deallocations to the leak table.  Returns `1' if
     such logging was already being performed and `0' otherwise.

`int __mp_stopleaktable(void)'
     Stops the automatic logging of all memory allocations,
     reallocations and deallocations to the leak table.  Returns `1' if
     such logging was already being performed and `0' otherwise.

`void __mp_leaktable(size_t size, int opt, unsigned char flags)'
     Displays a summary of up to SIZE entries from the leak table, or
     all entries if SIZE is `0'.  If OPT is `MP_LT_ALLOCATED' then all
     allocated entries will be displayed, if OPT is `MP_LT_FREED' then
     all freed entries will be displayed and if OPT is `MP_LT_UNFREED'
     then all unfreed entries will be displayed.  The summary is
     normally sorted in descending order of total bytes from each
     entry, but this can be changed by setting FLAGS to any combination
     of `MP_LT_COUNTS' (to sort by the number of occurrences in each
     entry) and `MP_LT_BOTTOM' (to sort in ascending order).

`void __mp_memorymap(int stats)'
     If STATS is non-zero then the current statistics of the mpatrol
     library will be displayed.  If the heap contains at least one
     allocated, freed or free block then a map of the current heap will
     also be displayed.

`void __mp_summary(void)'
     Displays information about the current state of the mpatrol
     library, including its settings and any relevant statistics.

`int __mp_stats(__mp_heapinfo *info)'
     Obtains statistics about the current state of the heap and places
     them in INFO.  If this information could not be determined then
     `0' will be returned, otherwise `1' will be returned and INFO will
     contain the following information:

     _Field_       _Description_
     `acount'      Total number of allocated blocks.
     `atotal'      Total size of allocated blocks.
     `fcount'      Total number of free blocks.
     `ftotal'      Total size of free blocks.
     `gcount'      Total number of freed blocks.
     `gtotal'      Total size of freed blocks.
     `icount'      Total number of internal blocks.
     `itotal'      Total size of internal blocks.
     `mcount'      Total number of marked blocks.
     `mtotal'      Total size of marked blocks.

`void __mp_check(void)'
     Forces the library to perform an immediate check of the overflow
     buffers of every memory allocation and to ensure that nothing has
     overwritten any free blocks.  If any memory allocations made by
     the `alloca()' family of functions are out of scope then this
     function will also cause them to be freed.

`__mp_prologuehandler __mp_prologue(const __mp_prologuehandler func)'
     Installs a prologue function to be called before any memory
     allocation, reallocation or deallocation function.  This function
     will return a pointer to the previously installed prologue
     function, or the null pointer if no prologue function had been
     previously installed.  The following arguments will be used to
     call the prologue function (the last four arguments contain the
     function name, file name, line number and the return address of
     the calling function, or null pointers and zero if they cannot be
     determined):

     _Argument 1_  _Argument 2_  _Argument 3_  _Called by_
     `-1'          SIZE          ALIGN         `malloc()', etc.
     PTR           SIZE          ALIGN         `realloc()', etc.
     PTR           `-1'          `0'           `free()', etc.
     PTR           `-2'          `1'           `strdup()', etc.

`__mp_epiloguehandler __mp_epilogue(const __mp_epiloguehandler func)'
     Installs an epilogue function to be called after any memory
     allocation, reallocation or deallocation function.  This function
     will return a pointer to the previously installed epilogue
     function, or the null pointer if no epilogue function had been
     previously installed.  The following arguments will be used to
     call the epilogue function (the last four arguments contain the
     function name, file name, line number and the return address of
     the calling function, or null pointers and zero if they cannot be
     determined):

     _Argument_    _Called by_
     PTR           `malloc()', `realloc()', `strdup()', etc.
     `-1'          `free()', etc.

`__mp_nomemoryhandler __mp_nomemory(const __mp_nomemoryhandler func)'
     Installs a low-memory handler and returns a pointer to the
     previously installed handler, or the `NULL' pointer if no handler
     had been previously installed.  This will be called once by C
     memory allocation functions, and repeatedly by C++ memory
     allocation functions, when they would normally return `NULL'.  The
     four arguments contain the function name, file name, line number
     and the return address of the calling function, or null pointers
     and zero if they cannot be determined.  Note that this function is
     equivalent to `set_new_handler()' and will replace the handler
     installed by that function.

`int __mp_printf(const char *fmt, ...)'
     Writes format string FMT with variable arguments to the log file,
     with each line prefixed by `>'.  The final length of the string
     that is written to the log file must not exceed 1024 characters.
     Returns the number of characters written, or a negative number
     upon error.

`int __mp_vprintf(const char *fmt, va_list args)'
     Writes format string FMT with variable argument list ARGS to the
     log file, with each line prefixed by `>'.  The final length of the
     string that is written to the log file must not exceed 1024
     characters.  Returns the number of characters written, or a
     negative number upon error.

`void __mp_locprintf(const char *fmt, ...)'
     Writes format string FMT with variable arguments to the log file,
     with each line prefixed by `>'.  The final length of the string
     that is written to the log file must not exceed 1024 characters.
     It also writes information to the log file about where the call to
     this function was made, which includes the source file location
     and the call stack if they are available.

`void __mp_vlocprintf(const char *fmt, va_list args)'
     Writes format string FMT with variable argument list ARGS to the
     log file, with each line prefixed by `>'.  The final length of the
     string that is written to the log file must not exceed 1024
     characters.  It also writes information to the log file about
     where the call to this function was made, which includes the
     source file location and the call stack if they are available.

`void __mp_logmemory(const void *ptr, size_t size)'
     Displays the contents of a block of memory beginning at PTR,
     dumping SIZE consecutive bytes to the log file in hexadecimal
     format.

`int __mp_logstack(size_t frames)'
     Displays the current call stack, skipping FRAMES stack frames from
     the current stack frame before writing the symbolic stack trace to
     the log file.  Returns `1' if successful, or `0' if the call stack
     could not be determined or if FRAMES was too large for the current
     call stack.

`int __mp_logaddr(const void *ptr)'
     Displays information about a specific memory allocation containing
     PTR to the log file.  If PTR does not belong to a previously
     allocated memory allocation then `0' will be returned, otherwise
     `1' will be returned.

`int __mp_edit(const char *file, unsigned long line)'
     Invokes a text editor to edit FILE at line number LINE via the
     `mpedit' command.  Returns `1' if the text editor was successfully
     invoked, `-1' if there was an error, or `0' if there is no support
     for this feature.  This function will only work on a system where
     the `EDIT' option works.

`int __mp_list(const char *file, unsigned long line)'
     Displays a context listing of FILE at line number LINE via the
     `mpedit' command.  Returns `1' if the listing was successfully
     performed, `-1' if there was an error, or `0' if there is no
     support for this feature.  This function will only work on a
     system where the `LIST' option works.

`int __mp_view(const char *file, unsigned long line)'
     Either invokes a text editor to edit FILE at line number LINE or
     displays a context listing of FILE at line number LINE depending
     on the setting of the `EDIT' and `LIST' options.  This is done via
     the `mpedit' command and will have no effect if the `EDIT' and
     `LIST' options are not set or if these options are not supported
     on the system.  Returns `1' if the edit or listing was
     successfully performed, `-1' if there was an error, or `0' if
     neither of the options were set or if there is no support for this
     feature.

`int __mp_readcontents(const char *file, void *ptr)'
     Reads the contents of a memory allocation contents file into the
     memory allocation containing PTR.  The name of the file is
     composed of the FILE string followed by the allocation index of
     the memory allocation separated by a dot.  If FILE is `NULL' then
     it is assumed to be `.mpatrol'.  Returns `1' if the contents were
     read successfully and `0' otherwise.

`int __mp_writecontents(const char *file, const void *ptr)'
     Writes the contents of the memory allocation containing PTR to an
     allocation contents file.  The name of the file is composed of the
     FILE string followed by the allocation index of the memory
     allocation separated by a dot.  If FILE is `NULL' then it is
     assumed to be `.mpatrol'.  Returns `1' if the contents were
     written successfully and `0' otherwise.

`long __mp_cmpcontents(const char *file, const void *ptr)'
     Compares the contents of the memory allocation containing PTR with
     the contents of a previously written allocation contents file.
     The name of the file is composed of the FILE string followed by
     the allocation index of the memory allocation separated by a dot.
     If FILE is `NULL' then it is assumed to be `.mpatrol'.  Any
     differences are written to the mpatrol log file.  Returns the
     number of differences found, or `-1' if there was an error.

`int __mp_remcontents(const char *file, const void *ptr)'
     Removes the memory allocation contents file that corresponds to
     the memory allocation containing PTR.  The name of the file is
     composed of the FILE string followed by the allocation index of
     the memory allocation separated by a dot.  If FILE is `NULL' then
     it is assumed to be `.mpatrol'.  Returns `1' if the file was
     removed successfully and `0' otherwise.


File: mpatrol.info,  Node: Environment,  Next: Options,  Prev: Functions,  Up: Top

Appendix B Environment
**********************

The library can read certain options at run-time from an environment
variable called `MPATROL_OPTIONS'.  This variable must contain one or
more valid option keywords from the list below and must be no longer
than 1024 characters in length.  If `MPATROL_OPTIONS' is unset or empty
then the default settings will be used.

   The syntax for options specified within the `MPATROL_OPTIONS'
environment variable is `OPTION' or `OPTION=VALUE', where `OPTION' is a
keyword from the list below and `VALUE' is the setting for that option.
If `VALUE' is numeric then it may be specified using binary, octal,
decimal or hexadecimal notation, with binary notation beginning with
either `0b' or `0B'.  If `VALUE' is a character string containing
spaces then it may be quoted using double quotes.  No whitespace may
appear between the `=' sign, but whitespace must appear between
different options.  Note that option keywords can be given in lowercase
as well as uppercase, or a mixture of both.

`ALLOCBYTE'=<UNSIGNED-INTEGER>
     Specifies an 8-bit byte pattern with which to prefill
     newly-allocated memory.  This can be used to detect the use of
     memory which has not been initialised after allocation.  Note that
     this setting will not affect memory allocated with `calloc()' or
     `recalloc()' as these functions always prefill allocated memory
     with an 8-bit byte pattern of zero.  Default value:
     `ALLOCBYTE=0xFF'.

`ALLOCSTOP'=<UNSIGNED-INTEGER>
     Specifies an allocation index at which to stop the program when it
     is being allocated.  When the number of memory allocations reaches
     this number the program will be halted, and its state may be
     examined at that point by using a suitable debugger.  Note that
     this setting will be ignored if its value is zero.  Default value:
     `ALLOCSTOP=0'.

`ALLOWOFLOW'
     Specifies that a warning rather than an error should be produced
     if any memory operation function overflows the boundaries of a
     memory allocation, and that the operation should still be
     performed.  This option is provided for circumstances where it is
     desirable for the memory operation to be performed, regardless of
     whether it is erroneous or not.

`AUTOSAVE'=<UNSIGNED-INTEGER>
     Specifies the frequency at which to periodically write the
     profiling data to the profiling output file.  When the total
     number of profiled memory allocations and deallocations is a
     multiple of this number then the current profiling information
     will be written to the profiling output file.  This option can be
     used to instruct the mpatrol library to dump out any profiling
     information just before a fatal error occurs in a program, for
     example.  Note that this setting will be ignored if its value is
     zero.  Default value: `AUTOSAVE=0'.

`CHECK'=<UNSIGNED-RANGE>
     Specifies a range of allocation indices at which to check the
     integrity of free memory and overflow buffers.  The range must be
     specified as no more than two unsigned integers separated by a
     dash, followed by an optional forward slash and an unsigned
     integer specifying an event checking frequency.  If numbers on
     either the left side or the right side of the dash are omitted
     then they will be assumed to be `0' and INFINITY respectively.  A
     value of `0' on its own indicates that no such checking will ever
     be performed.  This option can be used to speed up the execution
     speed of the library at the expense of checking.  Default value:
     `CHECK=0'.

`CHECKALL'
     Equivalent to the `CHECKALLOCS', `CHECKREALLOCS', `CHECKFREES' and
     `CHECKMEMORY' options specified together.

`CHECKALLOCS'
     Checks that no attempt is made to allocate a block of memory of
     size zero.  A warning will be issued for every such case.

`CHECKFORK'
     Checks at every call to see if the process has been forked in case
     new log, profiling and tracing output files need to be started.
     This option only has an effect on UNIX platforms, but should not
     be used in multithreaded programs if each thread has a different
     process identifier.

`CHECKFREES'
     Checks that no attempt is made to deallocate a `NULL' pointer.  A
     warning will be issued for every such case.

`CHECKMEMORY'
     Checks that no attempt is made to perform a zero-length memory
     operation or a memory operation on a `NULL' pointer.

`CHECKREALLOCS'
     Checks that no attempt is made to reallocate a `NULL' pointer or
     resize an existing block of memory to size zero.  Warnings will be
     issued for every such case.

`DEFALIGN'=<UNSIGNED-INTEGER>
     Specifies the default alignment for general-purpose memory
     allocations, which must be a power of two (and will be rounded up
     to the nearest power of two if it is not).  The default alignment
     for a particular system is calculated at run-time.

`EDIT'
     Specifies that a text editor should be invoked to edit any
     relevant source files that are associated with any warnings or
     errors when they occur.  Only diagnostics which occur at source
     lines in the program will be affected and only then if they
     contain source-level information.  This option is currently only
     available on UNIX platforms as it makes use of the `mpedit'
     command.  It also overrides the behaviour of the `LIST' option and
     affects the behaviour of the `__mp_view()' function.

`FAILFREQ'=<UNSIGNED-INTEGER>
     Specifies the frequency at which all memory allocations will
     randomly fail.  For example, a value of `10' will mean that
     roughly 1 in 10 memory allocations will fail, but a value of `0'
     will disable all random failures.  This option can be useful for
     stress-testing an application.  Default value: `FAILFREQ=0'.

`FAILSEED'=<UNSIGNED-INTEGER>
     Specifies the random number seed which will be used when
     determining which memory allocations will randomly fail.  A value
     of `0' will instruct the library to pick a random seed every time
     it is run.  Any other value will mean that the random failures
     will be the same every time the program is run, but only as long
     as the seed stays the same.  Default value: `FAILSEED=0'.

`FREEBYTE'=<UNSIGNED-INTEGER>
     Specifies an 8-bit byte pattern with which to prefill newly-freed
     memory.  This can be used to detect the use of memory which has
     just been freed.  It is also used internally to ensure that freed
     memory has not been overwritten.  Note that the freed memory may
     be reused the next time a block of memory is allocated and so once
     memory has been freed its contents are not guaranteed to remain
     the same as the specified byte pattern.  Default value:
     `FREEBYTE=0x55'.

`FREESTOP'=<UNSIGNED-INTEGER>
     Specifies an allocation index at which to stop the program when it
     is being freed.  When the memory allocation with the specified
     allocation index is to be freed the program will be halted, and
     its state may be examined at that point using a suitable debugger.
     Note that this setting will be ignored if its value is zero.
     Default value: `FREESTOP=0'.

`HELP'
     Displays a quick-reference option summary to the `stderr' file
     stream.

`LARGEBOUND'=<UNSIGNED-INTEGER>
     Specifies the limit in bytes up to which memory allocations should
     be classified as large allocations for profiling purposes.  This
     limit must be greater than the small and medium bounds.  Default
     value: `LARGEBOUND=2048'.

`LEAKTABLE'
     Specifies that the leak table should be automatically used and a
     leak table summary should be displayed at the end of program
     execution.  The summary shows a flat profile of all unfreed memory
     allocations since the start of the program, or since the last call
     to `__mp_clearleaktable()' if that function was called.

`LIMIT'=<UNSIGNED-INTEGER>
     Specifies the limit in bytes at which all memory allocations
     should fail if the total allocated memory should increase beyond
     this.  This can be used to stress-test software to see how it
     behaves in low memory conditions.  The internal memory used by the
     library itself will not be counted as part of the total heap size,
     but on some systems there may be a small amount of memory required
     to initialise the library itself.  Note that this setting will be
     ignored if its value is zero.  Default value: `LIMIT=0'.

`LIST'
     Specifies that a context listing should be shown for any relevant
     source files that are associated with any warnings or errors when
     they occur.  Only diagnostics which occur at source lines in the
     program will be affected and only then if they contain
     source-level information.  This option is currently only available
     on UNIX platforms as it makes use of the `mpedit' command.  It
     also overrides the behaviour of the `EDIT' option and affects the
     behaviour of the `__mp_view()' function.

`LOGALL'
     Equivalent to the `LOGALLOCS', `LOGREALLOCS', `LOGFREES' and
     `LOGMEMORY' options specified together.

`LOGALLOCS'
     Specifies that all memory allocations are to be logged and sent to
     the log file.  Note that any memory allocations made internally by
     the library will not be logged.

`LOGFILE'=<STRING>
     Specifies an alternative file in which to place all diagnostics
     from the mpatrol library.  If the `LOGDIR' environment variable is
     set and the specified file does not contain a path component in
     its filename then the log file will be located in the directory
     specified in `LOGDIR'.  A filename of `stderr' will send all
     diagnostics to the `stderr' file stream and a filename of `stdout'
     will do the equivalent with the `stdout' file stream.  Note that
     if a problem occurs while opening the log file or if any
     diagnostics require to be displayed before the log file has had a
     chance to be opened then they will be sent to the `stderr' file
     stream.  Default value: `LOGFILE=mpatrol.log' or
     `LOGFILE=%n.%p.log' if the `LOGDIR' environment variable is set.

`LOGFREES'
     Specifies that all memory deallocations are to be logged and sent
     to the log file.  Note that any memory deallocations made
     internally by the library will not be logged.

`LOGMEMORY'
     Specifies that all memory operations are to be logged and sent to
     the log file.  These operations will be made by calls to functions
     such as `memset()' and `memcpy()'.  Note that any memory
     operations made internally by the library will not be logged.

`LOGREALLOCS'
     Specifies that all memory reallocations are to be logged and sent
     to the log file.  Note that any memory reallocations made
     internally by the library will not be logged.

`MEDIUMBOUND'=<UNSIGNED-INTEGER>
     Specifies the limit in bytes up to which memory allocations should
     be classified as medium allocations for profiling purposes.  This
     limit must be greater than the small bound but less than the large
     bound.  Default value: `MEDIUMBOUND=256'.

`NOFREE'=<UNSIGNED-INTEGER>
     Specifies that a number of recently-freed memory allocations
     should be prevented from being returned to the free memory pool.
     Such freed memory allocations will then be flagged as freed and
     can be used by the library to provide better diagnostics.  If the
     size of the freed queue is specified as zero then all freed memory
     will be immediately reused by the mpatrol library.  Note that if
     this option is given a non-zero value then the mpatrol library
     will always force a memory reallocation to return a pointer to
     newly-allocated memory, but the `expand()' function will never be
     affected by this option.  Default value: `NOFREE=0'.

`NOPROTECT'
     Specifies that the mpatrol library's internal data structures
     should not be made read-only after every memory allocation,
     reallocation or deallocation.  This may significantly speed up
     execution but this will be at the expense of less safety if the
     program accidentally overwrites some of the library's internal data
     structures.  Note that this option has no effect on systems that
     do not support memory protection.

`OFLOWBYTE'=<UNSIGNED-INTEGER>
     Specifies an 8-bit byte pattern with which to fill the overflow
     buffers of all memory allocations.  This is used internally to
     ensure that nothing has been written beyond the beginning or the
     end of a block of allocated memory.  Note that this setting will
     only have an effect if the `OFLOWSIZE' option is in use.  Default
     value: `OFLOWBYTE=0xAA'.

`OFLOWSIZE'=<UNSIGNED-INTEGER>
     Specifies the size in bytes to use for all overflow buffers, which
     must be a power of two (and will be rounded up to the nearest
     power of two if it is not).  This is used internally to ensure
     that nothing has been written beyond the beginning or the end of a
     block of allocated memory.  Note that this setting specifies the
     size for only one of the overflow buffers given to each memory
     allocation; the other overflow buffer will have an identical size.
     No overflow buffers will be used if this setting is zero.  Default
     value: `OFLOWSIZE=0'.

`OFLOWWATCH'
     Specifies that watch point areas should be used for overflow
     buffers rather than filling with the overflow byte.  This can
     significantly reduce the speed of program execution.  Note that
     this option has no effect on systems that do not support watch
     point areas.

`PAGEALLOC'=<`LOWER'|`UPPER'>
     Specifies that each individual memory allocation should occupy at
     least one page of virtual memory and should be placed at the
     lowest or highest point within these pages.  This allows the
     library to place an overflow buffer of one page on either side of
     every memory allocation and write-protect these pages as well as
     all free and freed memory.  Note that this option has no effect on
     systems that do not support memory protection, and is disabled by
     default on other systems as it can slow down the speed of program
     execution.

`PRESERVE'
     Specifies that any reallocated or freed memory allocations should
     preserve their original contents.  This option must be used with
     the `NOFREE' option and has no effect otherwise.

`PROF'
     Specifies that all memory allocations and deallocations are to be
     profiled and sent to the profiling output file.  Memory
     reallocations are treated as a memory deallocation immediately
     followed by a memory allocation.

`PROFFILE'=<STRING>
     Specifies an alternative file in which to place all memory
     allocation profiling information from the mpatrol library.  If the
     `PROFDIR' environment variable is set and the specified file does
     not contain a path component in its filename then the profiling
     output file will be located in the directory specified in
     `PROFDIR'.  A filename of `stderr' will send this information to
     the `stderr' file stream and a filename of `stdout' will do the
     equivalent with the `stdout' file stream.  Note that if a problem
     occurs while opening the profiling output file then the profiling
     information will not be output.  Default value:
     `PROFFILE=mpatrol.out' or `PROFFILE=%n.%p.out' if the `PROFDIR'
     environment variable is set.

`PROGFILE'=<STRING>
     Specifies an alternative filename with which to locate the
     executable file containing the program's symbols.  On most
     systems, the library will automatically be able to determine this
     filename, but on a few systems this option may have to be used
     before any or all symbols can be read.

`REALLOCSTOP'=<UNSIGNED-INTEGER>
     Specifies a reallocation index at which to stop the program when a
     memory allocation is being reallocated.  If the `ALLOCSTOP' option
     is non-zero then the program will be halted when the allocation
     matching that allocation index is reallocated the specified number
     of times.  Otherwise the program will be halted the first time any
     allocation is reallocated the specified number of times.  Note
     that this setting will be ignored if its value is zero.  Default
     value: `REALLOCSTOP=0'.

`SAFESIGNALS'
     Instructs the library to save and replace certain signal handlers
     during the execution of library code and to restore them
     afterwards.  This was the default behaviour in version 1.0 of the
     mpatrol library and was changed since some memory-intensive
     programs became very hard to interrupt using the keyboard, thus
     giving the impression that the program or system had hung.

`SHOWALL'
     Equivalent to the `SHOWFREE', `SHOWFREED', `SHOWUNFREED',
     `SHOWMAP' and `SHOWSYMBOLS' options specified together.

`SHOWFREE'
     Specifies that a summary of all of the free memory blocks should
     be displayed at the end of program execution.  This step will not
     be performed if an abnormal termination occurs or if there were no
     free memory blocks.

`SHOWFREED'
     Specifies that a summary of all of the freed memory allocations
     should be displayed at the end of program execution.  This option
     must be used in conjunction with the `NOFREE' option and this step
     will not be performed if an abnormal termination occurs or if
     there were no freed allocations.

`SHOWMAP'
     Specifies that a memory map of the entire heap should be displayed
     at the end of program execution.  This step will not be performed
     if an abnormal termination occurs or if the heap is empty.

`SHOWSYMBOLS'
     Specifies that a summary of all of the function symbols read from
     the program's executable file should be displayed at the end of
     program execution.  This step will not be performed if an abnormal
     termination occurs or if no symbols could be read from the
     executable file.

`SHOWUNFREED'
     Specifies that a summary of all of the unfreed memory allocations
     should be displayed at the end of program execution.  This step
     will not be performed if an abnormal termination occurs or if
     there are no unfreed allocations.  Note that any marked memory
     allocations will not be listed.

`SMALLBOUND'=<UNSIGNED-INTEGER>
     Specifies the limit in bytes up to which memory allocations should
     be classified as small allocations for profiling purposes.  This
     limit must be greater than zero but less than the medium and large
     bounds.  Default value: `SMALLBOUND=32'.

`TRACE'
     Specifies that all memory allocations, reallocations and
     deallocations are to be traced and sent to the tracing output file.

`TRACEFILE'=<STRING>
     Specifies an alternative file in which to place all memory
     allocation tracing information from the mpatrol library.  If the
     `TRACEDIR' environment variable is set and the specified file does
     not contain a path component in its filename then the tracing
     output file will be located in the directory specified in
     `TRACEDIR'.  A filename of `stderr' will send this information to
     the `stderr' file stream and a filename of `stdout' will do the
     equivalent with the `stdout' file stream.  Note that if a problem
     occurs while opening the tracing output file then the tracing
     information will not be output.  Default value:
     `TRACEFILE=mpatrol.trace' or `TRACEFILE=%n.%p.trace' if the
     `TRACEDIR' environment variable is set.

`UNFREEDABORT'=<UNSIGNED-INTEGER>
     Specifies the minimum number of unfreed allocations at which to
     abort the program just before program termination.  A summary of
     all the allocations will be displayed on the standard error file
     stream before aborting.  This option may be handy for use in batch
     tests as it can force tests to fail if they do not free up a
     minimum number of memory allocations, although marked allocations
     will not be considered as unfreed allocations.  Note that this
     setting will be ignored if its value is zero.  Default value:
     `UNFREEDABORT=0'.

`USEDEBUG'
     Specifies that any debugging information in the executable file
     should be used to obtain additional source-level information.
     This option will only have an effect if the executable file
     contains a compiler-generated line number table and will be
     ignored if the mpatrol library was built to support an object file
     access library that cannot read line tables from object files.
     Note that this option will slow down program execution, use up
     more system memory and may leave unaccounted unfreed memory
     allocations at program termination.

`USEMMAP'
     Specifies that the library should use `mmap()' instead of `sbrk()'
     to allocate user memory on UNIX platforms.  This option should be
     used if there are problems when using the mpatrol library in
     combination with another malloc library which uses `sbrk()' to
     allocate its memory.  Memory internal to the mpatrol library is
     allocated with `mmap()' on systems where it is supported in order
     to segregate it from user memory, and this behaviour is reversed
     with the `USEMMAP' option.  It is ignored on systems that do not
     support the `mmap()' system call.  Note that some UNIX systems
     require this option in order for the mpatrol library to be able to
     perform memory protection with the `mprotect()' system call.


File: mpatrol.info,  Node: Options,  Next: Diagnostic messages,  Prev: Environment,  Up: Top

Appendix C Options
******************

A utility program called `mpatrol' is provided to run commands that have
been linked with the mpatrol library.

     mpatrol [options] <command> [arguments]

   The `mpatrol' command is used to set various mpatrol library OPTIONS
when running COMMAND with its ARGUMENTS.  In most cases, COMMAND must
have been linked with the mpatrol library, unless the `--dynamic'
option is used in which case COMMAND need only have been dynamically
linked.

   All mpatrol library diagnostics are sent to the file
`mpatrol.%n.log' in the current directory by default (where `%n' is the
current process id) but this can be changed using the `--log-file'
option.  Similarly, the default profiling output filename is
`mpatrol.%n.out' and the default tracing output filename is
`mpatrol.%n.trace'.

   Alternatively, the log file, profiling output file and tracing
output file names can contain `%p', which will be replaced with the
name of the program being executed without the directory components.
If the executable filename could not be determined or was not set then
it will be replaced with `mpatrol'.  A similar replacement character
sequence is `%f', which will be replaced by the pathname of the program
being executed, with all path separation characters replaced by
underscores.

   The current date can be entered into such filenames through the use
of the `%d' character sequence, which will be replaced with the date in
the form `YYYYMMDD'.  The current time can be added with `%t', which
will be replaced with the time in the form `HHMMSS'.  If the date or
time could not be determined, these will be replaced with `today' and
`now' respectively.

   All of the following options (except `--dynamic', `--help',
`--read-env', `--show-env', `--threads' and `--version') correspond to
their listed mpatrol library option (*note Environment::).  Note that
some of these options have a one character equivalent option that can
be used for brevity.  The list of one character options can be viewed
with the `--help' option or viewed in the UNIX manual pages.  Such
options are parsed on the command line in a similar way to the UNIX
function `getopt()'.

`--alloc-byte' <UNSIGNED-INTEGER>
     [`ALLOCBYTE']  Specifies an 8-bit byte pattern with which to
     prefill newly-allocated memory.

`--alloc-stop' <UNSIGNED-INTEGER>
     [`ALLOCSTOP']  Specifies an allocation index at which to stop the
     program when it is being allocated.

`--allow-oflow'
     [`ALLOWOFLOW']  Specifies that a warning rather than an error
     should be produced if any memory operation function overflows the
     boundaries of a memory allocation, and that the operation should
     still be performed.

`--auto-save' <UNSIGNED-INTEGER>
     [`AUTOSAVE']  Specifies the frequency at which to periodically
     write the profiling data to the profiling output file.

`--check' <UNSIGNED-RANGE>
     [`CHECK']  Specifies a range of allocation indices at which to
     check the integrity of free memory and overflow buffers.

`--check-all'
     [`CHECKALL']  Equivalent to the `--check-allocs',
     `--check-reallocs', `--check-frees' and `--check-memory' options
     specified together.

`--check-allocs'
     [`CHECKALLOCS']  Checks that no attempt is made to allocate a
     block of memory of size zero.

`--check-fork'
     [`CHECKFORK']  Checks at every call to see if the process has been
     forked in case new log, profiling and tracing output files need to
     be started.

`--check-frees'
     [`CHECKFREES']  Checks that no attempt is made to deallocate a
     `NULL' pointer.

`--check-memory'
     [`CHECKMEMORY']  Checks that no attempt is made to perform a
     zero-length memory operation or a memory operation on a `NULL'
     pointer.

`--check-reallocs'
     [`CHECKREALLOCS']  Checks that no attempt is made to reallocate a
     `NULL' pointer or resize an existing block of memory to size zero.

`--def-align' <UNSIGNED-INTEGER>
     [`DEFALIGN']  Specifies the default alignment for general-purpose
     memory allocations, which must be a power of two.

`--dynamic'
     Specifies that programs which were not linked with the mpatrol
     library should also be traced, but only if they were dynamically
     linked.  This option will only work if the system dynamic linker
     has the ability to preload a set of user-specified shared
     libraries via a special environment variable.

`--edit'
     [`EDIT']  Specifies that a text editor should be invoked to edit
     any relevant source files that are associated with any warnings or
     errors when they occur.

`--fail-freq' <UNSIGNED-INTEGER>
     [`FAILFREQ']  Specifies the frequency at which all memory
     allocations will randomly fail.

`--fail-seed' <UNSIGNED-INTEGER>
     [`FAILSEED']  Specifies the random number seed which will be used
     when determining which memory allocations will randomly fail.

`--free-byte' <UNSIGNED-INTEGER>
     [`FREEBYTE']  Specifies an 8-bit byte pattern with which to prefill
     newly-freed memory.

`--free-stop' <UNSIGNED-INTEGER>
     [`FREESTOP']  Specifies an allocation index at which to stop the
     program when it is being freed.

`--help'
     Displays a quick-reference option summary.

`--large-bound' <UNSIGNED-INTEGER>
     [`LARGEBOUND']  Specifies the limit in bytes up to which memory
     allocations should be classified as large allocations for
     profiling purposes.

`--leak-table'
     [`LEAKTABLE'] Specifies that the leak table should be
     automatically used and a leak table summary should be displayed at
     the end of program execution.

`--limit' <UNSIGNED-INTEGER>
     [`LIMIT']  Specifies the limit in bytes at which all memory
     allocations should fail if the total allocated memory should
     increase beyond this.

`--list'
     [`LIST']  Specifies that a context listing should be shown for any
     relevant source files that are associated with any warnings or
     errors when they occur.

`--log-all'
     [`LOGALL']  Equivalent to the `--log-allocs', `--log-reallocs',
     `--log-frees' and `--log-memory' options specified together.

`--log-allocs'
     [`LOGALLOCS']  Specifies that all memory allocations are to be
     logged and sent to the log file.

`--log-file' <STRING>
     [`LOGFILE']  Specifies an alternative file in which to place all
     diagnostics from the mpatrol library.

`--log-frees'
     [`LOGFREES']  Specifies that all memory deallocations are to be
     logged and sent to the log file.

`--log-memory'
     [`LOGMEMORY']  Specifies that all memory operations are to be
     logged and sent to the log file.

`--log-reallocs'
     [`LOGREALLOCS']  Specifies that all memory reallocations are to be
     logged and sent to the log file.

`--medium-bound' <UNSIGNED-INTEGER>
     [`MEDIUMBOUND']  Specifies the limit in bytes up to which memory
     allocations should be classified as medium allocations for
     profiling purposes.

`--no-free' <UNSIGNED-INTEGER>
     [`NOFREE']  Specifies that a number of recently-freed memory
     allocations should be prevented from being returned to the free
     memory pool.

`--no-protect'
     [`NOPROTECT']  Specifies that the mpatrol library's internal data
     structures should not be made read-only after every memory
     allocation, reallocation or deallocation.

`--oflow-byte' <UNSIGNED-INTEGER>
     [`OFLOWBYTE']  Specifies an 8-bit byte pattern with which to fill
     the overflow buffers of all memory allocations.

`--oflow-size' <UNSIGNED-INTEGER>
     [`OFLOWSIZE']  Specifies the size in bytes to use for all overflow
     buffers, which must be a power of two.

`--oflow-watch'
     [`OFLOWWATCH']  Specifies that watch point areas should be used for
     overflow buffers rather than filling with the overflow byte.

`--page-alloc-lower'
     [`PAGEALLOC=LOWER']  Specifies that each individual memory
     allocation should occupy at least one page of virtual memory and
     should be placed at the lowest point within these pages.

`--page-alloc-upper'
     [`PAGEALLOC=UPPER']  Specifies that each individual memory
     allocation should occupy at least one page of virtual memory and
     should be placed at the highest point within these pages.

`--preserve'
     [`PRESERVE']  Specifies that any reallocated or freed memory
     allocations should preserve their original contents.

`--prof'
     [`PROF']  Specifies that all memory allocations are to be profiled
     and sent to the profiling output file.

`--prof-file' <STRING>
     [`PROFFILE']  Specifies an alternative file in which to place all
     memory allocation profiling information from the mpatrol library.

`--prog-file' <STRING>
     [`PROGFILE']  Specifies an alternative filename with which to
     locate the executable file containing the program's symbols.

`--read-env'
     Reads and passes through the contents of the `MPATROL_OPTIONS'
     environment variable.  Such contents will be placed before any of
     the options resulting from `mpatrol' command line options so that
     they can be overridden and will only be parsed by the mpatrol
     library, _not_ the `mpatrol' command.

`--realloc-stop' <UNSIGNED-INTEGER>
     [`REALLOCSTOP']  Specifies an allocation index at which to stop the
     program when a memory allocation is being reallocated.

`--safe-signals'
     [`SAFESIGNALS']  Instructs the library to save and replace certain
     signal handlers during the execution of library code and to
     restore them afterwards.

`--show-all'
     [`SHOWALL']  Equivalent to the `--show-free', `--show-freed',
     `--show-unfreed', `--show-map' and `--show-symbols' options
     specified together.

`--show-env'
     Displays the contents of the `MPATROL_OPTIONS' environment
     variable.  This will be shown after all of the other command line
     options have been processed and will prevent the specified command
     from being run.

`--show-free'
     [`SHOWFREE']  Specifies that a summary of all of the free memory
     blocks should be displayed at the end of program execution.

`--show-freed'
     [`SHOWFREED']  Specifies that a summary of all of the freed memory
     allocations should be displayed at the end of program execution.

`--show-map'
     [`SHOWMAP']  Specifies that a memory map of the entire heap should
     be displayed at the end of program execution.

`--show-symbols'
     [`SHOWSYMBOLS']  Specifies that a summary of all of the function
     symbols read from the program's executable file should be
     displayed at the end of program execution.

`--show-unfreed'
     [`SHOWUNFREED']  Specifies that a summary of all of the unfreed
     memory allocations should be displayed at the end of program
     execution.

`--small-bound' <UNSIGNED-INTEGER>
     [`SMALLBOUND']  Specifies the limit in bytes up to which memory
     allocations should be classified as small allocations for
     profiling purposes.

`--threads'
     Specifies that the program to be run is multithreaded if the
     `--dynamic' option is used.  This option is required if the
     multithreaded version of the mpatrol library should be preloaded
     instead of the normal version.

`--trace'
     [`TRACE']  Specifies that all memory allocations are to be traced
     and sent to the tracing output file.

`--trace-file' <STRING>
     [`TRACEFILE']  Specifies an alternative file in which to place all
     memory allocation tracing information from the mpatrol library.

`--unfreed-abort' <UNSIGNED-INTEGER>
     [`UNFREEDABORT']  Specifies the minimum number of unfreed
     allocations at which to abort the program just before program
     termination.

`--use-debug'
     [`USEDEBUG']  Specifies that any debugging information in the
     executable file should be used to obtain additional source-level
     information.

`--use-mmap'
     [`USEMMAP']  Specifies that the library should use `mmap()' instead
     of `sbrk()' to allocate user memory.

`--version'
     Displays the version number of the `mpatrol' command.


File: mpatrol.info,  Node: Diagnostic messages,  Next: Library performance,  Prev: Options,  Up: Top

Appendix D Diagnostic messages
******************************

The following table lists the warnings and errors that are likely to
appear in the mpatrol log file when problems with dynamic memory
allocations and memory operations occur.  Other types of warnings and
errors may also appear in the log file, but they are likely to be
associated with parsing options and reading symbols from executable
files and so should be self-explanatory.

   In all cases, if a warning or error is caused by one of the memory
access checking functions (invoked through the use of the
`-fcheck-memory-usage' option to the GNU compiler) then execution will
halt regardless, despite what the description of the diagnostic message
says.

   If a warning or error occurs due to a direct call to an mpatrol
library function then an attempt will be made to provide a log entry
for the call.  If the diagnostic was not caused by a normal memory
allocation, reallocation or deallocation function then the log entry
will be preceded by `LOG:'.  The function type will be listed as
`check' if it does not fall into the normal categories or if not enough
information is available.

   Note that on UNIX platforms, if the diagnostic message is caused by
a line in the program source then the `EDIT' and `LIST' options can be
used to illustrate more clearly where in the source code the warning or
error occurred.

   * `ALLOVF'
    Message
          `allocation %1 has a corrupted overflow buffer at %2'

    Type
          Error

    `%1'
          The pointer to the memory allocation that has a corrupted
          overflow buffer.

    `%2'
          The pointer to the first byte of corruption in the memory
          allocation's overflow buffer.

    Cause
          Something has corrupted the overflow buffer of a memory
          allocation and this has been caught at the next invocation of
          an mpatrol function when the `OFLOWSIZE' or `PAGEALLOC'
          options were used.  This particular error message will not
          occur if the `OFLOWWATCH' option was used since all overflow
          buffers will be write protected.

    Additional
          The log file entry, the library summary, the contents of the
          overflow buffer and information about the original memory
          allocation.

    Result
          Execution terminates.

   * `ALLZER'
    Message
          `attempt to create an allocation of size 0'

    Type
          Warning

    Cause
          A function was called to allocate memory with a size of `0'
          when either of the `CHECKALL' or `CHECKALLOCS' options were
          used.  This warning will not occur by default as the ANSI
          C/C++ standards allow this behaviour, and it is really only a
          portability issue.

    Additional
          The log file entry.

    Result
          The size is increased to 1 byte and execution continues.

   * `BADALN'
    Message
          `alignment %1 is not a power of two'

    Type
          Warning

    `%1'
          The alignment in bytes.

    Cause
          The `memalign()' function was called to allocate memory with
          an alignment which was not a power of two when either of the
          `CHECKALL' or `CHECKALLOCS' options were used.

    Additional
          The log file entry.

    Result
          The alignment is rounded up to the nearest power of two and
          execution continues.

   * `FRDCOR'
    Message
          `freed allocation %1 has memory corruption at %2'

    Type
          Error

    `%1'
          The pointer to the freed memory allocation that has been
          corrupted.

    `%2'
          The pointer to the first byte of corruption in the freed
          memory allocation.

    Cause
          Something has corrupted the contents of a previously freed
          memory allocation and this has been caught at the next
          invocation of an mpatrol function when the `NOFREE' option
          was used.  This particular error message will not occur if
          the `PAGEALLOC' option was used since all freed memory
          allocations will be write protected and will also not occur
          if the `PRESERVE' option was used since the free byte cannot
          be used to verify the freed allocation's contents.

    Additional
          The log file entry, the library summary, the contents of the
          freed memory block and information about the original memory
          allocation.

    Result
          Execution terminates.

   * `FRDOPN'
    Message
          `attempt to perform operation on freed memory'

    Type
          Error

    Cause
          A memory operation function was called to operate on a
          previously freed memory allocation when the `NOFREE' option
          was used.

    Additional
          The log file entry and information about the original memory
          allocation.

    Result
          The memory operation fails and execution continues.

   * `FRDOVF'
    Message
          `freed allocation %1 has a corrupted overflow buffer at %2'

    Type
          Error

    `%1'
          The pointer to the freed memory allocation that has a
          corrupted overflow buffer.

    `%2'
          The pointer to the first byte of corruption in the freed
          memory allocation's overflow buffer.

    Cause
          Something has corrupted the overflow buffer of a previously
          freed memory allocation and this has been caught at the next
          invocation of an mpatrol function when the `NOFREE' option
          was used in conjunction with the `OFLOWSIZE' or `PAGEALLOC'
          options.  This particular error message will not occur if the
          `OFLOWWATCH' option was used since all overflow buffers will
          be write protected.

    Additional
          The log file entry, the library summary, the contents of the
          overflow buffer and information about the original memory
          allocation.

    Result
          Execution terminates.

   * `FRECOR'
    Message
          `free memory corruption at %1'

    Type
          Error

    `%1'
          The pointer to the first byte of corruption in free memory.

    Cause
          Something has corrupted the contents of the free memory pool
          and this has been caught at the next invocation of an mpatrol
          function.  This particular error message will not occur if
          the `PAGEALLOC' option was used since all free memory will be
          write protected.

    Additional
          The log file entry, the library summary and the contents of
          the free memory block.

    Result
          Execution terminates.

   * `FREMRK'
    Message
          `attempt to free marked allocation %1'

    Type
          Error

    `%1'
          The pointer to the memory allocation that has been requested
          to be freed.

    Cause
          An attempt was made to free a marked memory allocation.  This
          is not allowed since any memory allocations that have been
          marked indicate to the mpatrol library that they should
          remain allocated for the duration of the program.

    Additional
          The log file entry and information about the original memory
          allocation.

    Result
          No memory allocation will be freed and execution continues.

   * `FRENUL'
    Message
          `attempt to free a NULL pointer'

    Type
          Warning

    Cause
          A function was called to free an existing memory allocation
          with a pointer of `NULL' when either of the `CHECKALL' or
          `CHECKFREES' options were used.  This warning will not occur
          by default as the ANSI C/C++ standards allow this behaviour,
          and it is really only a portability issue.

    Additional
          The log file entry.

    Result
          No memory allocation will be freed and execution continues.

   * `FREOPN'
    Message
          `attempt to perform operation on free memory'

    Type
          Error

    Cause
          A memory operation function was called to operate on free
          memory.

    Additional
          The log file entry.

    Result
          The memory operation fails and execution continues.

   * `ILLMEM'
    Message
          `illegal memory access at address %1'

    Type
          Error

    `%1'
          The address at which the illegal memory access occurred.

    Cause
          An attempt was made to read from or write to an illegal
          address on systems which have virtual memory.  This address
          may or may not exist in the heap, or it may be a perfectly
          valid address that was misaligned and caused a bus error.  In
          either case, the mpatrol library will attempt to associate
          the address with an existing memory allocation.  This error
          may also appear instead of memory corruption errors if the
          `PAGEALLOC' or `OFLOWWATCH' options were used.

    Additional
          The library summary, information about the original memory
          allocation (if possible) and the call stack of where the
          error occurred.

    Result
          Execution terminates.

   * `INCOMP'
    Message
          `%1 was allocated with %2'

    Type
          Error

    `%1'
          The pointer to the memory allocation that is to be resized or
          freed.

    `%2'
          The name of the function which originally allocated the
          memory allocation.

    Cause
          A function was called to resize or free a memory allocation
          that was allocated with a function that is incompatible with
          the current request.  For example, a memory allocation which
          was allocated with `operator new' being resized with
          `realloc()'.

    Additional
          The log file entry and information about the original memory
          allocation.

    Result
          The reallocation or deallocation fails and execution
          continues.

   * `MAXALN'
    Message
          `alignment %1 is greater than the system page size'

    Type
          Warning

    `%1'
          The alignment in bytes.

    Cause
          The `memalign()' function was called to allocate memory with
          an alignment which was greater than the system page size when
          either of the `CHECKALL' or `CHECKALLOCS' options were used.
          The mpatrol library cannot currently align memory allocations
          to a byte alignment over this limit, but then neither can
          most other implementations.

    Additional
          The log file entry.

    Result
          The alignment is set to the system page size and execution
          continues.

   * `MISMAT'
    Message
          `%1 does not match allocation of %2'

    Type
          Error

    `%1'
          The pointer to the memory allocation that is to be resized or
          freed.

    `%2'
          The pointer to the memory allocation that the mpatrol library
          knows about.

    Cause
          A function was called to resize or free a memory allocation
          that begins at a different address from that supplied.

    Additional
          The log file entry and information about the original memory
          allocation.

    Result
          The reallocation or deallocation fails and execution
          continues.

   * `NOTALL'
    Message
          `%1 has not been allocated'

    Type
          Error

    `%1'
          The pointer to the memory allocation that is to be resized or
          freed.

    Cause
          A function was called to resize or free a memory allocation
          that has not been allocated.  It may be that the memory
          allocation has just been freed, in which case the `NOFREE'
          option should be used to provide a better diagnostic message.

    Additional
          The log file entry.

    Result
          The reallocation or deallocation fails and execution
          continues.

   * `NULOPN'
    Message
          `attempt to perform operation on a NULL pointer'

    Type
          Error

    Cause
          A memory operation function was called to operate on a `NULL'
          pointer.  If the length of the operation was zero then this
          error will only occur when the `CHECKALL' or `CHECKMEMORY'
          options were used as the ANSI C/C++ standards allow this
          behaviour, and it is really only a portability issue.

    Additional
          The log file entry.

    Result
          The memory operation fails and execution continues.

   * `OUTMEM'
    Message
          `out of memory'

    Type
          Error

    Cause
          The `alloca()', `xmalloc()' or `MP_MALLOC()' families of
          functions were called to allocate memory, but no more memory
          was available to allocate and the low-memory handler, if
          installed, could not free up sufficient memory.  This error
          can also be caused by a call to the `operator new' or
          `operator new[]' C++ operators (not the _nothrow_ versions)
          when they would otherwise return a `NULL' pointer and the
          mpatrol library was compiled with a C compiler (which means
          that it cannot throw a `std::bad_alloc' exception).

    Additional
          The library summary.

    Result
          Execution terminates.

   * `PRVFRD'
    Message
          `%1 was freed with %2'

    Type
          Error

    `%1'
          The pointer to the memory allocation that is to be resized or
          freed.

    `%2'
          The name of the function which originally freed the memory
          allocation.

    Cause
          A function was called to resize or free a memory allocation
          that had previously been freed when the `NOFREE' option was
          used.

    Additional
          The log file entry and information about the original memory
          allocation.

    Result
          The reallocation or deallocation fails and execution
          continues.

   * `RNGOVF'
    Message
          `range [%1,%2] overflows [%3,%4]'

    Type
          Warning/Error

    `%1'
          The start address of the memory region.

    `%2'
          The end address of the memory region.

    `%3'
          The start address of the memory allocation.

    `%4'
          The end address of the memory allocation.

    Cause
          A memory operation function was called to operate on a range
          of memory which overflowed the boundaries of a memory
          allocation.

    Additional
          The log file entry and information about the original memory
          allocation.

    Result
          The operation will be only be performed (and will be changed
          from an error to a warning) if the `ALLOWOFLOW' option was
          used, but execution will continue regardless.

   * `RNGOVL'
    Message
          `range [%1,%2] overlaps [%3,%4]'

    Type
          Warning

    `%1'
          The start address of the source memory region.

    `%2'
          The end address of the source memory region.

    `%3'
          The start address of the destination memory region.

    `%4'
          The end address of the destination memory region.

    Cause
          The `memcpy()' or `memccpy()' function was called to copy
          overlapping memory regions.  This is an error on many systems
          and the ANSI C/C++ standards specify that `memmove()' should
          be used instead.

    Additional
          The log file entry.

    Result
          The copy operation will still be performed but it will deal
          correctly with overlapping memory regions.

   * `RSZNUL'
    Message
          `attempt to resize a NULL pointer'

    Type
          Warning

    Cause
          A function was called to resize an existing memory allocation
          with a pointer of `NULL' when either of the `CHECKALL' or
          `CHECKREALLOCS' options were used.  This warning will not
          occur by default as the ANSI C/C++ standards allow this
          behaviour, and it is really only a portability issue.

    Additional
          The log file entry.

    Result
          A new memory allocation is returned and execution continues.

   * `RSZZER'
    Message
          `attempt to resize an allocation to size 0'

    Type
          Warning

    Cause
          A function was called to resize an existing memory allocation
          to a size of `0' when either of the `CHECKALL' or
          `CHECKREALLOCS' options were used.  This warning will not
          occur by default as the ANSI C/C++ standards allow this
          behaviour, and it is really only a portability issue.

    Additional
          The log file entry.

    Result
          The existing memory allocation will be freed and execution
          continues.

   * `STROVF'
    Message
          `string %1 overflows [%2,%3]'

    Type
          Error

    `%1'
          The start address of the string.

    `%2'
          The start address of the memory allocation.

    `%3'
          The end address of the memory allocation.

    Cause
          A string function was called to operate on a string which
          overflowed the boundaries of a memory allocation.

    Additional
          The log file entry and information about the original memory
          allocation.

    Result
          The operation will not be performed and execution continues.

   * `ZERALN'
    Message
          `alignment 0 is invalid'

    Type
          Warning

    Cause
          The `memalign()' function was called to allocate memory with
          an alignment of `0' when either of the `CHECKALL' or
          `CHECKALLOCS' options were used.

    Additional
          The log file entry.

    Result
          The alignment is set to the default system alignment and
          execution continues.

   * `ZEROPN'
    Message
          `attempt to perform a zero-sized operation'

    Type
          Warning

    Cause
          A memory operation function was called with a length of zero.
          This warning will only occur when the `CHECKALL' or
          `CHECKMEMORY' options were used as the ANSI C/C++ standards
          allow this behaviour, and it is really only a portability
          issue.

    Additional
          The log file entry.

    Result
          The operation will not be performed and execution continues.


File: mpatrol.info,  Node: Library performance,  Next: File formats,  Prev: Diagnostic messages,  Up: Top

Appendix E Library performance
******************************

The following times were obtained on a Sun Ultra 5 with an UltraSPARC
IIi processor running at 333MHz and running Solaris 7.  The test
performed was the one in `tests/pass/test1.c' and all tests were run on
a lightly loaded system, but were run several times to obtain an
average result.  Obviously, these times can only be an approximation,
but should serve to illustrate the effects on performance that each
option can have.  All times are given in seconds, and the second time
on each line was obtained with the same options plus the `NOPROTECT'
option.  The tests were all run with the default `CHECK=0' option, so
running with the `CHECK=-' option would slow things down dramatically,
albeit with more checking being performed to detect heap corruption.

   Running with basic options:

_no options_                                0.525       0.258
`OFLOWSIZE=2'                               0.569       0.265
`OFLOWSIZE=8'                               0.580       0.276
`PAGEALLOC=LOWER'                           0.709       0.462
`PAGEALLOC=UPPER'                           0.742       0.485

   Running when all freed memory allocations are kept:

`NOFREE=0xFFFF'                             0.711       0.338
`NOFREE=0xFFFF OFLOWSIZE=2'                 0.725       0.350
`NOFREE=0xFFFF OFLOWSIZE=8'                 0.739       0.358
`NOFREE=0xFFFF PAGEALLOC=LOWER'             1.048       0.710
`NOFREE=0xFFFF PAGEALLOC=UPPER'             1.079       0.722

   Running when all freed memory allocations are kept and their
contents are preserved:

`NOFREE=0xFFFF PRESERVE'                    0.725       0.341
`NOFREE=0xFFFF PRESERVE OFLOWSIZE=2'        0.735       0.357
`NOFREE=0xFFFF PRESERVE OFLOWSIZE=8'        0.745       0.360
`NOFREE=0xFFFF PRESERVE PAGEALLOC=LOWER'    1.055       0.722
`NOFREE=0xFFFF PRESERVE PAGEALLOC=UPPER'    1.081       0.729

   Running using watch points to check the overflow buffers:

`OFLOWSIZE=2 OFLOWWATCH'                    28.758      28.372

   Running using the Solaris malloc libraries:

Solaris malloc(3c) library                  0.030
Solaris malloc(3x) library                  0.033
Solaris bsdmalloc(3x) library               0.027
Solaris mapmalloc(3x) library               0.030
Solaris watchmalloc(3x) library             30.323


File: mpatrol.info,  Node: File formats,  Next: Supported systems,  Prev: Library performance,  Up: Top

Appendix F File formats
***********************

The formats of the profiling and tracing output files that are produced
by the mpatrol library are described here(1).

* Menu:

* Profiling file format::       Profiling output file layout.
* Tracing file format::         Tracing output file layout.

   ---------- Footnotes ----------

   (1) The file `extra/magic' contains a UNIX _magic_ file excerpt for
automatically identifying an mpatrol log file, an mpatrol profiling
output file and an mpatrol tracing output file with the `file' command.


File: mpatrol.info,  Node: Profiling file format,  Next: Tracing file format,  Up: File formats

F.1 Profiling file format
=========================

Every mpatrol profiling output file contains the following components.

   * 4 bytes containing the characters `M', `P', `T' and `L'.

   * 1 unsigned integer representing the value `1'.  This is used by
     `mprof' to determine the endianness of the processor that produced
     the profiling output file so that it can decide whether to perform
     byte-swapping on the input data.

   * 1 unsigned integer containing the version number of the mpatrol
     library which produced the profiling output file.

   * 3 unsigned integers containing the small, medium and large
     allocation bounds.

   * 1 unsigned integer containing the allocation bin size.  If the
     allocation bin size is greater than zero then it is followed by
     the allocation bins, the large allocation totals, the deallocation
     bins and the large deallocation totals, where the bins are arrays
     of unsigned integers with dimensions of the allocation bin size
     and the totals are unsigned integers.

   * 1 unsigned integer containing the number of profiling data
     structures.  If the number of profiling data structures is greater
     than zero then it is followed by the profiling data structures
     themselves, which are of the following structure.

        * 1 unsigned integer representing the index of this profiling
          data.

        * 4 unsigned integers representing the small, medium, large and
          extra large allocation counts for this profiling data.

        * 4 unsigned integers representing the small, medium, large and
          extra large allocation totals for this profiling data.

        * 4 unsigned integers representing the small, medium, large and
          extra large deallocation counts for this profiling data.

        * 4 unsigned integers representing the small, medium, large and
          extra large deallocation totals for this profiling data.

   * 1 unsigned integer containing the number of call sites.  If the
     number of call sites is greater than zero then it is followed by
     the call sites themselves, which are of the following structure.

        * 1 unsigned integer representing the index of this call site.

        * 1 unsigned integer representing the index of the parent call
          site.

        * 1 generic pointer representing the code address of this call
          site.

        * 1 unsigned integer representing the index of an associated
          symbol.

        * 1 unsigned integer representing the offset of the symbol name.

        * 1 unsigned integer representing the index of any associated
          profiling data.

   * 1 unsigned integer containing the number of symbol addresses.  If
     the number of symbol addresses is greater than zero then it is
     followed by the symbol addresses themselves, which are generic
     pointers.

   * 1 unsigned integer containing the size of the symbol name string
     table.  This is followed by the symbol name string table, which is
     an array of characters containing the nul-terminated symbol names.

   * 4 bytes containing the characters `M', `P', `T' and `L'.


File: mpatrol.info,  Node: Tracing file format,  Prev: Profiling file format,  Up: File formats

F.2 Tracing file format
=======================

Every mpatrol tracing output file contains the following components.

   * 4 bytes containing the characters `M', `T', `R' and `C'.

   * 1 unsigned integer representing the value `1'.  This is used by
     `mptrace' to determine the endianness of the processor that
     produced the tracing output file so that it can decide whether to
     perform byte-swapping on the input data.

   * 1 unsigned integer containing the version number of the mpatrol
     library which produced the tracing output file.

   * One or more of the following event records.

        * If the event is a system heap allocation for use by the
          mpatrol library's internal data structures then the event
          record will begin with the character `I' followed by the
          start address and size in bytes of the heap allocation
          encoded as unsigned LEB128 numbers.

        * If the event is a system heap allocation for use by the
          program's memory allocations then the event record will begin
          with the character `H' followed by the start address and size
          in bytes of the heap allocation encoded as unsigned LEB128
          numbers.

        * If the event is a memory allocation then the event record
          will begin with the character `A' followed by the allocation
          index, start address and size in bytes of the memory
          allocation encoded as unsigned LEB128 numbers.  From version
          1.4.5 of the mpatrol library, the thread identifier, function
          name, file name and line number are also written out as part
          of the event record (see below).

        * If the event is a memory reallocation then the event record
          will begin with the character `R' followed by the allocation
          index, start address and size of the new memory allocation
          encoded as an unsigned LEB128 number.  From version 1.4.5 of
          the mpatrol library, the thread identifier, function name,
          file name and line number are also written out as part of the
          event record (see below).

        * If the event is a memory deallocation then the event record
          will begin with the character `F' followed by the allocation
          index of the memory allocation encoded as an unsigned LEB128
          number.  From version 1.4.5 of the mpatrol library, the
          thread identifier, function name, file name and line number
          are also written out as part of the event record (see below).

   * From version 1.4.5 of the mpatrol library, event records contain
     the following additional information.

        * The thread identifier as an unsigned LEB128 number.

        * The cached source function name.  If the first byte is zero
          then there is no associated function name.  If the first byte
          has the most significant bit set then the following
          null-terminated string defines a source function name
          associated with the number in the remaining 7 bits.  If the
          first byte does not have the most significant bit set then it
          is taken to be the index of a previously defined source
          function name.

        * The cached source file name.  If the first byte is zero then
          there is no associated file name.  If the first byte has the
          most significant bit set then the following null-terminated
          string defines a source file name associated with the number
          in the remaining 7 bits.  If the first byte does not have the
          most significant bit set then it is taken to be the index of
          a previously defined source file name.

        * The source line number as an unsigned LEB128 number.

   * 4 bytes containing the characters `M', `T', `R' and `C'.


File: mpatrol.info,  Node: Supported systems,  Next: Porting,  Prev: File formats,  Up: Top

Appendix G Supported systems
****************************

Following is a list of systems on which the mpatrol library has been
built and tested.  The system details include the operating system and
version, the processor type, the object file format and the compiler
used to compile the library and tests.  The details following each
system list any features of the library that are not (or cannot be)
supported on that system.

   * AIX 4.1, IBM RS/6000, XCOFF, `cc'
        * The thread-safe version of the library does not work.

        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * There is a problem obtaining the program's executable
          filename when using the shared library version of mpatrol.

        * The shared library version of mpatrol does not currently
          override the dynamic memory allocation functions that are
          called from other shared libraries and so will only affect
          object files that are statically linked.  If this is a problem
          then should link your programs with the following additional
          compiler options in order to perform a static link instead of
          a dynamic link: `-bnoautoimp' `-bimport:/lib/syscalls.exp'
          and also `-bimport:/lib/threads.exp' if linking with
          `libmpatrolmt.a'.

        * A makefile called `Makefile.aix' is supplied in `build/unix'
          which will build the mpatrol library as an AIX shared
          library.  The shared library will be embedded within the
          mpatrol archive library as is done with the system libraries.

        * The `__mp_init_' initialisation function feature does not
          work since function entry points need to be referenced
          through the TOC.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * DG/UX 4.11, Intel Pentium Pro, ELF32, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * DG/UX 4.20MU07, Intel Pentium Pro, ELF32, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libelf.so' is available.

   * DG/UX 4.11, Motorola 88100, ELF32, `gcc'
        * The thread-safe version of the library does not work if the
          mpatrol library is built as a shared library.

        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * Call stack traversal only works with unoptimised code.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * DRS/NX 6.2, SPARC V7, ELF32, `cc'
        * The option `-DSYSTEM=SYSTEM_DRSNX' must be added to the
          `CFLAGS' section in the `Makefile' before building the
          library.

        * The thread-safe version of the library does not work.  This
          is because there does not appear to be any evidence that this
          version of the operating system supports threads.

        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * DYNIX/ptx 4.5, Intel Pentium Pro, ELF32, `cc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libelf.so' is available.

   * FreeBSD 4.2, Intel Celeron, ELF32, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * On ELF-based systems, the mpatrol library requires either the
          ELF access library or the GNU BFD library to be installed on
          the system, otherwise no symbols can be read from executable
          files or shared libraries and the library must be built with
          the `-DFORMAT=FORMAT_NONE' option.  No such extra libraries
          are required on `a.out'-based systems.

        * The `--dynamic' option to the `mpatrol' command does not
          appear to work correctly, giving spurious errors in the log
          file.

   * HP/UX 10.20, HP PA/RISC 9000, BFD, `gcc'
        * The thread-safe version of the library does not work.  This
          is because there does not appear to be any evidence that this
          version of the operating system supports threads.

        * The `OFLOWWATCH' option has no effect.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * Interix 3.5, Intel Pentium 4, PE-COFF, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEMMAP' option must be used in order for the `PAGEALLOC'
          option to detect illegal memory accesses.

        * The `USEDEBUG' option has no effect.

        * The `-fPIC' option for `gcc' should not be used when building
          the mpatrol shared libraries as it currently doesn't generate
          correct code.

        * The shared libraries `libmpatrol.so' and `libmpatrolmt.so'
          must be linked with the dynamic linker `/lib/ld.so' at build
          time in order for the `--dynamic' option to the `mpatrol'
          command to be able to find the symbols for any dependent
          shared libraries.

   * IRIX 5.3, MIPS R4000, ELF32, `cc'
        * The thread-safe version of the library does not work.  This
          is because there does not appear to be any evidence that this
          version of the operating system supports threads.

        * This version of the operating system only allows up to 100
          user-programmable software watch points, which means that the
          `OFLOWWATCH' option will not work properly if more than 50
          memory allocations exist at one time.

        * The `USEDEBUG' option has no effect.

        * Stack traversal may be unreliable from signal-handlers.

   * Red Hat Linux 6.0, Intel Pentium III, BFD, `g++'
        * The `OFLOWWATCH' option has no effect.

        * The `CHECKFORK' option does not work properly in
          multithreaded programs due to each thread having different
          process identifiers.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libiberty.so' and `libintl.so' are available.

   * Red Hat Linux 6.1, Intel Pentium III, BFD, `g++'
        * The thread-safe version of the library does not work due to
          the system threads library calling `malloc()' and `bzero()'
          recursively.

        * The `OFLOWWATCH' option has no effect.

        * The `CHECKFORK' option does not work properly in
          multithreaded programs due to each thread having different
          process identifiers.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libiberty.so' and `libintl.so' are available.

   * Red Hat Linux 6.2, Intel Pentium III, BFD, `g++'
        * The `OFLOWWATCH' option has no effect.

        * The `CHECKFORK' option does not work properly in
          multithreaded programs due to each thread having different
          process identifiers.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libiberty.so' and `libintl.so' are available.

   * Red Hat Linux 7.x, Intel Pentium III, BFD, `g++'
        * The `OFLOWWATCH' option has no effect.

        * The `CHECKFORK' option does not work properly in
          multithreaded programs due to each thread having different
          process identifiers.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libiberty.so' and `libintl.so' are available.

   * Red Hat Linux 5.1, Motorola 68040, BFD, `gcc'
        * The thread-safe version of the library does not work due to
          the system threads library calling `malloc()' and `bzero()'
          recursively.

        * The `OFLOWWATCH' option has no effect.

        * The `CHECKFORK' option does not work properly in
          multithreaded programs due to each thread having different
          process identifiers.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libiberty.so' and `libintl.so' are available.

   * Red Hat Linux 5.1, Motorola 68040, ELF32, `gcc'
        * The thread-safe version of the library does not work due to
          the system threads library calling `malloc()' and `bzero()'
          recursively.

        * The `OFLOWWATCH' option has no effect.

        * The `CHECKFORK' option does not work properly in
          multithreaded programs due to each thread having different
          process identifiers.

        * The `USEDEBUG' option has no effect.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libelf.so' is available.

   * SuSE Linux 7.1, Intel Pentium II, BFD, `g++'
        * The `OFLOWWATCH' option has no effect.

        * The `CHECKFORK' option does not work properly in
          multithreaded programs due to each thread having different
          process identifiers.

        * The `--dynamic' option to the `mpatrol' command does not work
          unless `libiberty.so' and `libintl.so' are available.

   * LynxOS 3.0.0, Intel Pentium Pro, BFD, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEMMAP' option has no effect.

        * There is currently no support for reading symbols from COFF
          shared libraries.  You should currently always perform a
          static link instead of a dynamic link when linking your
          program, but that is the default on LynxOS anyway.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * LynxOS 3.0.0, Intel Pentium Pro, COFF, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `USEMMAP' option has no effect.

        * There is currently no support for reading symbols from COFF
          shared libraries.  You should currently always perform a
          static link instead of a dynamic link when linking your
          program, but that is the default on LynxOS anyway.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * LynxOS 3.0.0, PowerPC, BFD, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEMMAP' option has no effect.

        * There is currently no support for reading symbols from XCOFF
          shared libraries.  You should currently always perform a
          static link instead of a dynamic link when linking your
          program, but that is the default on LynxOS anyway.

        * The `__mp_init_' initialisation function feature does not
          work since function entry points need to be referenced
          through the TOC.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * LynxOS 3.0.0, PowerPC, XCOFF, `gcc'
        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `USEMMAP' option has no effect.

        * There is currently no support for reading symbols from XCOFF
          shared libraries.  You should currently always perform a
          static link instead of a dynamic link when linking your
          program, but that is the default on LynxOS anyway.

        * The `__mp_init_' initialisation function feature does not
          work since function entry points need to be referenced
          through the TOC.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * SINIX 5.43, MIPS R4000, ELF32, `cc'
        * The thread-safe version of the library does not work.  This
          is because there does not appear to be any evidence that this
          version of the operating system supports threads.

        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * Stack traversal may be unreliable from signal-handlers.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * Solaris 2.6, Intel Pentium Pro, BFD, `gcc'
        * No known issues.

   * Solaris 2.6, Intel Pentium Pro, ELF32, `gcc'
        * The `USEDEBUG' option has no effect.

   * Solaris 2.5, SPARC V8, BFD, `gcc'
        * The thread-safe version of the library does not work due to a
          problem with a system library.

        * The `OFLOWWATCH' option has no effect.  The
          `-DMP_PROCFS_SUPPORT=0' and `-DMP_WATCH_SUPPORT=0' options
          must be added to `CFLAGS' in the `Makefile'.

   * Solaris 2.5, SPARC V8, ELF32, `gcc'
        * The thread-safe version of the library does not work due to a
          problem with a system library.

        * The `OFLOWWATCH' option has no effect.  The
          `-DMP_PROCFS_SUPPORT=0' and `-DMP_WATCH_SUPPORT=0' options
          must be added to `CFLAGS' in the `Makefile'.

        * The `USEDEBUG' option has no effect.

   * Solaris 7, SPARC V9, BFD, `g++'
        * The mpatrol library can be compiled and run in a 64-bit
          environment.

   * Solaris 7, SPARC V9, ELF32/ELF64, `g++'
        * The `USEDEBUG' option has no effect.

        * The mpatrol library can be compiled and run in a 64-bit
          environment.

   * Solaris 8, SPARC V9, BFD, `g++'
        * The mpatrol library can be compiled and run in a 64-bit
          environment.

   * Solaris 8, SPARC V9, ELF32/ELF64, `g++'
        * The `USEDEBUG' option has no effect.

        * The mpatrol library can be compiled and run in a 64-bit
          environment.

   * Tru64 5.0, Alpha, BFD, `cxx'
        * The thread-safe version of the library has not yet been
          tested.

        * The `OFLOWWATCH' option has no effect.

        * The system exception-handling library (libexc) is used for
          call stack traversal.  Unfortunately, this library makes
          several calls to `malloc()' when initialising itself and this
          can sometimes result in a recursive loop when used in
          combination with the mpatrol library.  If this occurs, the
          mpatrol library must be built without the `malloc.o' module.

        * The mpatrol library can be compiled and run in a 64-bit
          environment.

   * UnixWare 7.1.1, Intel Pentium II, ELF32, `gcc'
        * The option `-DSYSTEM=SYSTEM_UNIXWARE' must be added to the
          `CFLAGS' section in the `Makefile' before building the
          library.

        * The thread-safe version of the library does not work.

        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `--dynamic' option to the `mpatrol' command has no effect.

   * AmigaOS 3.1, Motorola 68040, BFD, `gcc'
        * No memory protection so the `PAGEALLOC' option has no effect.

        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `USEMMAP' option has no effect.

        * The `EDIT' and `LIST' options have no effect.

        * Limited support for call stack traversal.

        * Limited support for reading symbols.

        * No detection of illegal memory accesses.

        * The `__mp_init_' initialisation function feature does not
          work.

        * The `--dynamic' option to the `mpatrol' command has no effect.

        * The `mptrace' command has no GUI.

        * The `mpsym' and `hexwords' commands do not work unless `gdb'
          and the GNU text processing tools are installed.

        * The `mpedit' command does not work.

   * AmigaOS 3.1, Motorola 68040, n/a, SAS/C
        * No automatic override of `malloc()', etc., without inclusion
          of `mpatrol.h'.

        * No memory protection so the `PAGEALLOC' option has no effect.

        * The `OFLOWWATCH' option has no effect.

        * The `USEDEBUG' option has no effect.

        * The `USEMMAP' option has no effect.

        * The `EDIT' and `LIST' options have no effect.

        * No support for call stack traversal.

        * No support for reading symbols.

        * No detection of illegal memory accesses.

        * The C++ compiler may come with an older version of the
          standard C++ library which does not place `set_new_hander()'
          in the `std' namespace.  The `mpatrol.h' header file and the
          `cplus.c' source file will need to be changed accordingly.

        * The `__mp_init_' initialisation function feature does not
          work.

        * The `--dynamic' option to the `mpatrol' command has no effect.

        * The `mptrace' command has no GUI.

        * The `mpsym', `mpedit' and `hexwords' commands do not work.

   * Microsoft Windows NT 4.0, Intel Pentium III, IMAGEHLP, Microsoft
     Visual C++
        * The `OFLOWWATCH' option has no effect.

        * The `USEMMAP' option has no effect.

        * The `EDIT' and `LIST' options have no effect.

        * The C++ compiler may come with an older version of the
          standard C++ library which does not place `set_new_hander()'
          in the `std' namespace.  The `mpatrol.h' header file and the
          `cplus.c' source file will need to be changed accordingly.

        * There is currently a problem when mixing the archive library
          version of mpatrol with the DLL version of the Microsoft
          Runtime Library, and vice versa.

        * The `__mp_init_' initialisation function feature does not
          work.

        * The `--dynamic' option to the `mpatrol' command has no effect.

        * The `mptrace' command has no GUI.

        * The `mpsym', `mpedit' and `hexwords' commands do not work.


File: mpatrol.info,  Node: Porting,  Next: Notes,  Prev: Supported systems,  Up: Top

Appendix H Porting
******************

This section describes how to port the mpatrol library to new systems.
It is not a complete set of guidelines as nothing can cover every
eventuality, but it should list most of the important issues and where
to make the necessary changes.  Once you've made the changes (and are
happy with them) then send them to me and I can incorporate them into
the next mpatrol release.  I'd also like to hear from anybody who has
got mpatrol working on a different version of an operating system
listed in the supported systems section (*note Supported systems::)
even if no changes were required, since that information can be useful
for new users wondering if mpatrol can be used on their system.

  1. Make any required changes in `src/target.h' in order to identify
     the new system.

     The `TARGET' macro is used to identify distinct families of
     operating systems whereas the `SYSTEM' macro is used to identify
     the operating system variant if `TARGET=TARGET_UNIX'.  You should
     try to identify the predefined preprocessor macros that the system
     C compiler defines for the operating system type and the operating
     system variant, otherwise you will have to specify the `TARGET'
     and `SYSTEM' macros explicitly in the `Makefile' when building the
     mpatrol library.  Note that for non-UNIX operating systems,
     `SYSTEM=SYSTEM_ANY' is implied.

     The `ARCH' macro is used to identify the processor architecture
     and the `ENVIRON' macro is used to identify the processor word
     size.  Again, you should try to identify the predefined
     preprocessor macros that the system C compiler defines for the
     processor architecture and processor word size, otherwise you may
     also have to specify the `ARCH' and `ENVIRON' macros explicitly in
     the `Makefile' when building the mpatrol library.  The default
     setting for the processor word size is `ENVIRON=ENVIRON_32'.

     You can normally figure out the preprocessor macros that are
     predefined by the system C compiler by using the `-#', `-v' or
     `-verbose' options when compiling a source file.  The command line
     used to invoke the preprocessor should then be shown, which should
     show a list of all of the macros that are being defined in
     addition to those specified on the compiler command line.  It
     should then be easy for you to spot the ones you need.

     The `FORMAT' macro is used to identify the object file format and
     the `DYNLINK' macro is used to identify the dynamic linker type.
     You may be able to use the existing values for these without
     having to define new ones, but in any case you should attempt to
     set defaults for these macros depending on the values of the four
     preceding macros.  A setting of `FORMAT=FORMAT_NONE' indicates
     that reading symbols from any object files is not supported and a
     setting of `DYNLINK=DYNLINK_NONE' indicates that reading symbols
     from shared libraries is not supported.

     If the object file format of the new system is not currently
     supported, perhaps it is supported by the GNU BFD library.  This
     can be used as a catch-all solution to provide symbol reading
     support for the mpatrol library with object file formats that are
     obscure or are just hard to implement readers for.  You'd be
     surprised at how many object file formats are supported by that
     library and if the new format is supported then try defining
     `FORMAT=FORMAT_BFD' for the new system.

     In all six of the above target macros, care should be taken not to
     define a new macro that is effectively the same as an existing
     one, unless there are significant differences.  For example, the
     dynamic linker used on BSD systems is slightly different from the
     dynamic linker used on SunOS, but they both use
     `DYNLINK=DYNLINK_BSD' because the underlying dynamic linker uses
     the same data structures -- they are just named differently on the
     two systems.

     Note that there are also corresponding `*_STR' macros for all six
     of the above target macros.  These are used when displaying the
     target environment information in the mpatrol log file so they
     should be as accurate as possible so as to avoid misleading users.

     Finally, you should determine if it is necessary to define any
     special macros in order to obtain all of the required definitions
     from the system header files.  Many compilers default to providing
     an ANSI C or C++ environment without any extensions, but as the
     mpatrol library uses additional features that are not provided by
     these standards, it may be necessary to define additional macros
     that allow the compiler to see the definitions of these features.
     For example, the `_POSIX_SOURCE' macro is defined here for all
     UNIX platforms so that mpatrol can make use of the POSIX
     extensions.  Note that `src/target.h' is the only mpatrol library
     source file that refers to the predefined preprocessor macros
     defined by the system C compiler on a particular system (apart
     from a few necessary exceptions) and the rest of the source code
     refers to the six aforementioned macros for conditional
     compilation.

  2. Make any required changes in `src/memory.c' in order to support
     the new system.

     The mpatrol library, like the system malloc library it is
     replacing, must have some way of allocating memory from the system
     heap for a process.  For UNIX systems, this is done by calling
     `sbrk()' and/or `mmap()' but this is likely to be completely
     different for other operating systems.  The mpatrol library must
     also have some way of returning the allocated heap memory back to
     the operating system, although on systems with virtual memory this
     is not really an issue (see `MP_DELETEHEAP' in `src/config.h').
     If there is currently no support in the mpatrol library for
     allocating and returning system heap memory for the new system
     then you must modify `__mp_memalloc()' and `__mp_memfree()' to add
     the support.  You should define `MP_MMAP_SUPPORT' in
     `src/config.h' if the operating system is UNIX and the system
     variant supports the `mmap()' system call.

     Note that some (mainly embedded) systems may have no system heap
     available for a program to use.  If that is the case then the
     mpatrol library can be built to allocate memory from a static
     array whose size is fixed at compile-time.  The `MP_ARRAY_SUPPORT'
     macro should be defined in `src/config.h' and the `MP_ARRAY_SIZE'
     macro should be set to the maximum number of bytes that the
     simulated heap should be able to hold.  Keep in mind that all of
     the internal mpatrol library data structures will also be
     allocated from this array so it is important to make it large
     enough.

     Operating systems with virtual memory allow mpatrol to protect
     certain regions of heap memory to ensure that they are not
     overwritten.  The `MP_PROTECT_SUPPORT' macro in `src/config.h'
     controls whether the operating system supports this, and the
     `__mp_memprotect()' and `__mp_memquery()' functions should be
     updated to support the new system.  You should also define
     `MP_MINCORE_SUPPORT' in `src/config.h' if the operating system is
     UNIX and the system variant supports the `mincore()' system call.
     The `MP_WATCH_SUPPORT' macro controls the support of software
     watchpoints in a similar way and the `__mp_memwatch()' function
     should be updated if they are supported.

     If the new system is a UNIX system and it supports the `/proc'
     filesystem then you may wish to define `MP_PROCFS_SUPPORT' in
     `src/config.h'.  However, this is only necessary if there is a way
     to detect the filename the current process was invoked with
     (`MP_PROCFS_CMDNAME') or a way to obtain the filehandle of the
     executable file for the current process (`MP_PROCFS_EXENAME').  It
     may also be necessary if `MP_WATCH_SUPPORT' is defined and the
     only way to set the watchpoints is via a file in the `/proc'
     filesystem (`MP_PROCFS_CTLNAME').

     Finally, you should add support for determining the system page
     size in `pagesize()' and the process identifier for the current
     process in `__mp_processid()' if the system is not already
     supported(1).  You will also have to add a way to determine the
     filename that the current process was invoked with in
     `progname()', otherwise the `PROGFILE' option will always have to
     be used in order to read symbols from the executable file.  This
     can be done in a multitude of ways, including examining global
     variables, making function calls to query the system or traversing
     the call stack.

  3. Make any required changes in `src/stack.c' in order to support
     stack traversal in the new processor architecture.

     If the new processor architecture is CISC (complex instruction set
     computer) then the chances are that you can easily find the frame
     pointer and return address of the current stack frame by simply
     looking at a constant offset from the parameter to the
     `__mp_getframe()' function.  The call chain can then be obtained
     by following the frame pointer at each stage.  This can sometimes
     be disrupted by optimisations that do not preserve the frame
     pointer but this is usually confined to leaf routines and is not
     normally an issue.  The Intel x86 and Motorola 680x0 processor
     families are good examples to look at when implementing stack
     traversal for a CISC processor.

     On the other hand, things might not be so easy if the new
     processor architecture is RISC (reduced instruction set computer).
     Such processors do not always have fixed format stack frames(2)
     and so other means might have to be used.  The Alpha and MIPS
     processor families are examples of these and code reading normally
     has to be used in order to find the call instruction from the
     calling routine.  This then has to be done for every function in
     the call stack.  An example of such code can be found for the
     generic MIPS implementation.  Any assembler code that needs to be
     written to support the stack traversal implementation should be
     written in `src/machine.c'.

     If the GNU compiler is being used then it might be possible to use
     its `__builtin_frame_address()' and `__builtin_return_address()'
     builtin functions in order to provide stack traversal.  These can
     only be used if they return `NULL' when the bottom of the call
     stack is reached, but on many architectures the GNU compiler does
     not implement this correctly and so this method of stack traversal
     cannot be used.  Even if it can, it still imposes an upper limit
     on the size of the stack that can be traversed.  If this is not an
     issue then it can be enabled with the `MP_BUILTINSTACK_SUPPORT'
     macro in `src/config.h' and the maximum size of the call stack
     that can be traversed can be set by changing the `MP_MAXSTACK'
     macro in the same file.  The `MP_FULLSTACK' macro in
     `src/config.h' should be set for stack traversal implementations
     that have no limit to the maximum size of the call stack that can
     be traversed.  Obviously that is not the case for
     `MP_BUILTINSTACK_SUPPORT'.  A similar method can be used to
     traverse the stack using the `backtrace()' function from glibc
     with the `MP_GLIBCBACKTRACE_SUPPORT' preprocessor macro.

     Some operating systems have library functions that provide stack
     traversal facilities and so you may wish to make use of them by
     defining `MP_LIBRARYSTACK_SUPPORT' in `src/config.h' and
     implementing the code to call them in `src/stack.c'.  Examples of
     systems that can make use of this capability are IRIX and Tru64,
     although they have a drawback in that they recursively call
     `malloc()' and so work slower than they normally would.
     Alternatively, if libunwind has support for the processor
     architecture then you can try defining `MP_LIBUNWIND_SUPPORT' in
     `src/config.h' to see if that works.

     If any functions from an external system library were used to help
     implement stack traversal for the new processor architecture then
     you may also have to modify the `MP_SYSTEM_LIBS' definitions in
     `src/config.h', the `__mp_lib*' definitions in `src/inter.c' and
     the `AC_CHECK_LIB()' calls in `extra/mpatrol.m4'.

  4. Make any required changes in `src/symbol.c' in order to support
     any new object file formats and dynamic linkers.

     The best place to find information on the object file format and
     dynamic linker interface supported by a new system is the on-line
     manual pages and header files on that system.  If that fails then
     try the hardcopy technical reference manuals that came with the
     system or the internet in order to find the information you need.
     There may also be standards that define the object file format and
     dynamic linker interface across several systems.

     If you defined a new `FORMAT' macro in `src/target.h' then you must
     add the code to support it in `src/symbol.c'.  You will typically
     have to add new `addsymbol()' and `addsymbols()' functions that
     are specific to the new object file format and then add support
     for that format in `__mp_addsymbols()' and `__mp_findsymbol()'.
     If it is possible to easily read a line number table from the
     object file format then you may also want to extend the
     `__mp_findsource()' function to handle the new format as well in
     order to support the `USEDEBUG' option.

     If you defined a new `DYNLINK' macro in `src/target.h' then you
     must also add the code to support it in `src/symbol.c'.  You will
     normally only have to extend the `__mp_addextsymbols()' function
     to support the new dynamic linker but there may be some extra work
     required to translate the base addresses of any symbols read from
     shared libraries into real addresses.

     In both cases, try to base the new code on the structure of the
     existing code since it has been proven to work well and there is
     no point in reinventing the wheel(3).  You might decide to make
     changes to an existing implementation instead; this was done with
     the COFF and XCOFF formats, for example.

     If any functions from an external object file access library were
     used to help read symbols from the new object file format then you
     may also have to modify the `MP_SYMBOL_LIBS' definitions in
     `src/config.h', the `__mp_lib*' definitions in `src/inter.c' and
     the `AC_CHECK_LIB()' calls in `extra/mpatrol.m4'.

  5. Make any required changes in `src/signals.c' in order to obtain
     the address of an illegal memory access in the new system.

     If the system supports the `SA_SIGINFO' flag when setting up a
     signal handler with `sigaction()' then it supports
     architecture-independent determination of the address of an
     illegal memory access and the `MP_SIGINFO_SUPPORT' macro should be
     set in `src/config.h'.

     If this is not the case then an architecture-dependent method must
     be employed in order to obtain this information.  On UNIX systems,
     signal handlers can have additional arguments that may be used to
     probe for the address of a segmentation violation or bus error.
     On Windows systems, an exception record can be obtained whenever
     an access violation occurs.  In either case, the saved register
     containing the relevant address must be determined.  If this is
     not done then the mpatrol library will compile correctly, but the
     addresses of illegal memory accesses can never be determined.

  6. Make any required changes in `src/mutex.c' in order to support
     threads in the new system.

     The mpatrol library must be able to lock its data structures in a
     multithreaded environment otherwise two threads may allocate
     memory at the same time and the heap would become corrupted, for
     example.  On operating systems that have virtual memory, processes
     have their own address space and can have more than one thread of
     execution running at one time.  On other operating systems, there
     is only one process (the operating system) and the threads are the
     user processes that all share the same address space.  For that
     reason, you may wish to use semaphores on such systems since they
     have no support for threads in a conventional sense.

     For systems that do support threads, mutexes should be used to
     lock the mpatrol library data structures.  On UNIX platforms,
     POSIX threads are used but this could easily be extended to other
     threads implementations.  On Windows platforms, Win32 API threads
     are used.  For other systems, POSIX threads are preferred but it
     should not be too hard to add support for others.  There should
     also be a way to return the current thread identifier.

     You should also determine if it is necessary to define any special
     macros in order to obtain all of the required threadsafe
     definitions from the system header files.  Many compilers require
     an option to be specified on the command line in order to compile
     threadsafe code, but some still only require a preprocessor macro
     to be defined during compilation.  For example, the `_REENTRANT'
     macro is defined for Solaris systems so that mpatrol can make use
     of the threadsafe definitions.  Any such macros should be defined
     in `src/config.h' when `MP_THREADS_SUPPORT' is defined.

     The multithreaded version of the mpatrol library must be
     initialised before a process becomes multithreaded and so there
     must be a way to do this on a new system.

     The `MP_INIT_SUPPORT' macro should be defined in `src/config.h' if
     the new system supports `.init' and `.fini' sections that get
     executed before and after `main()' respectively.  Both the
     contents of the `.init' section (which should call
     `__mp_initmutexes()' and `__mp_init()') and the `.fini' section
     (which should call `__mp_fini()') should be written in
     `src/machine.c' in assembler code.

     There are also other methods to initialise and terminate the
     mpatrol library in `src/inter.c' so you may need to use one of
     them (or add a new method of your own) for the new system.  Note
     that if `MP_USE_ATEXIT' is defined in `src/config.h' then these
     methods of terminating the mpatrol library when a process ends are
     replaced by registering the `__mp_fini()' function with `atexit()'.

     There may be problems if the mpatrol library is built to override
     `malloc()' and related functions if the system C library calls
     them before the mpatrol library can be initialised.  There is a
     function in `src/inter.c' on UNIX and Windows platforms called
     `crt_initialised()' which checks to see if it is safe to
     initialise the mpatrol library, and if not the relevant functions
     will use `sbrk()' to allocate the memory.  You may have to modify
     `crt_initialised()' to support the new system if there are
     initialisation problems.

     If there are no special methods to initialise the multithreaded
     version of the mpatrol library on a new system then it will simply
     be initialised at the first call to one of its functions,
     hopefully before the process has become multithreaded.

     If there is support for reading symbols from object files on the
     new system then you should compile and run the following test with
     the mpatrol library to check to see if there is support for
     calling functions by their start address.  This is not always true
     on certain systems and will most likely result in the test
     crashing if that is the case.  If the test works then the
     `MP_INITFUNC_SUPPORT' macro should be set in `src/config.h'.

          #include <stdio.h>
          #include "mpatrol.h"


          void __mp_init_test(void)
          {
              puts("__mp_init_* functions work");
          }


          void __mp_fini_test(void)
          {
              puts("__mp_fini_* functions work");
          }


          int main(void)
          {
              malloc(1);
              puts("there should be a line of output above and below");
              return EXIT_SUCCESS;
          }

     If any functions from an external threads library were used to
     lock the data structures of the multithreaded version of the
     mpatrol library then you may also have to modify the
     `MP_THREADS_LIBS' definitions in `src/config.h', the `__mp_lib*'
     definitions in `src/inter.c' and the `AC_CHECK_LIB()' calls in
     `extra/mpatrol.m4'.

  7. Make any required changes to `src/diag.c' in order to support the
     new system.

     If the directory separation characters used by filesystem
     pathnames on the new system are different to those already
     supported then you must modify `processfile()', `__mp_logfile()',
     `__mp_proffile()' and `__mp_tracefile()' in order to support them.
     The mpatrol library needs to know how to extract and join the
     directory and filename components in a pathname in order to
     support the special characters that may appear in the filenames
     specified in the `LOGFILE', `PROFFILE' and `TRACEFILE' options.

  8. Make any required changes to `src/version.c' in order to support
     the new system.

     Different operating systems have different ways of embedding
     version information into libraries.  For example, on AmigaOS the
     `version' command looks for the `$VER:' string in a binary file
     and displays any information following it.  If the new system uses
     a special format for embedding version information then an
     alternative definition for `__mp_version' should be added to
     `src/version.c'.  It might also be useful to make any necessary
     changes to the `mupdate' shell script in the `bin' directory in
     order to support the new format, although that is not strictly
     required as it is only used when building automated mpatrol
     releases.

     The RCS revision string of each mpatrol source file can also be
     embedded into the mpatrol library and its tools.  The way this is
     done is controlled by the `MP_IDENT_SUPPORT' macro in
     `src/config.h'.  If it is set then the system supports placing
     these strings in a special section in the object file via the
     `#ident' directive, otherwise the strings will be placed in a data
     section in the object file.

  9. Make any required changes in `src/mpatrol.c' in order to support
     executing external commands.

     The `mpatrol' command should be modified to support the execution
     of external commands on a new operating system.  The `exec()'
     family of functions are used on UNIX platforms, while the
     `spawn()' family of functions are used on Windows platforms.  The
     ANSI C `system()' function is currently used on all other
     platforms, but that runs the command indirectly via the system
     command line interpreter (shell) which is not usually very
     efficient.  You may also have to add the ability to find any
     commands using a search path.

     If the new operating system can support the `--dynamic' option of
     the `mpatrol' command then the `MP_PRELOAD_SUPPORT' macro should be
     defined in `src/config.h'.  The name of the environment variable
     that must be used to specify the list of shared libraries to
     preload should be given in `MP_PRELOAD_NAME' and the library
     separator string for the list should be given in `MP_PRELOAD_SEP'.
     The `MP_LIBNAME' macro may also need to be modified if the naming
     convention of shared libraries is different on the new system.
     Note that the `__mp_editfile()' function in `src/diag.c' may also
     need to be modified to prevent editor processes from being
     affected by the `--dynamic' option.

 10. Make any required changes in `src/mptrace.c' in order to support
     any new window systems.

     The `mptrace' command may be built as a text-only command line
     tool, or it may be built with GUI support if the `MP_GUI_SUPPORT'
     macro is defined in `src/config.h'.  If it is built with GUI
     support and the `--gui' option is specified then it becomes an
     event-driven tool and the code in `src/mptrace.c' has been written
     to reflect that.  The `mptrace' command currently only has Motif
     GUI support but if you wish to add support for a new window system
     then it shouldn't be too hard to do.  Note that you will probably
     have to add additional libraries to the `Makefile' when building
     `mptrace' with `MP_GUI_SUPPORT' defined.

 11. Make any required changes to the shell scripts in the `bin'
     directory.

     The `mpsym', `mpedit' and `hexwords' commands all require UNIX
     systems, or UNIX tools, to run.  If the new system has the ability
     to run these commands then you should check that they run as
     expected.  If not, you should make the necessary modifications to
     make them work, although it should be in a generic fashion as
     there are no checks for specific platforms or processors in these
     files.  You may also wish to add support for other debuggers in
     `mpsym' and other editors in `mpedit'.

 12. Add a new subdirectory to the `build' directory if a new operating
     system is being supported.

     A new `Makefile' should be added in the new subdirectory along
     with any extra system-specific files that might be needed to build
     the mpatrol library on the new system.  The new `Makefile' should
     be based upon one of the existing `Makefile's in the other
     subdirectories but should obviously differ in the
     platform-dependent areas.  You may wish to add more than one
     `Makefile' to support different types of compilers on the new
     operating system.

     You must also decide which object files should get built into the
     mpatrol library.  If it is not safe to override the system
     `malloc()' routines on the new system then you should not include
     `src/malloc.c', and the same goes for `src/cplus.c' and the C++
     operators.  If there is no `sbrk()' function provided on the new
     operating system then you should include `src/sbrk.c' if you need
     to call `sbrk()' in `src/inter.c'.

     If the new operating system uses a special archive or package
     format then you should add support for it by adding a new
     subdirectory to the `pkg' directory.  A `build' script should be
     added to the new subdirectory that will automatically build the
     archive or package file from scratch.  Include any additional
     files that you need to perform the build in the new subdirectory as
     well.

   ---------- Footnotes ----------

   (1) You will also have to make any changes to `pagesize()' in
`src/mpalloc.c' and possibly also have to define `MP_MEMALIGN_SUPPORT'
in `src/config.h' if the new system supports the `memalign()' function.

   (2) Although some do, and you can follow the instructions for CISC
processors above in order to provide stack traversal support for them.

   (3) You might also be interested to note that you can safely call
`malloc()' in this code to allocate memory -- just remember to clean up
after yourself!


File: mpatrol.info,  Node: Notes,  Next: Frequently asked questions,  Prev: Porting,  Up: Top

Appendix I Notes
****************

This section contains information about known bugs and limitations in
the mpatrol library as well as listing potential future enhancements.

   Bugs should be reported to <graemeroy@users.sourceforge.net> along
with the details of the operating system, processor architecture and
object file format that the mpatrol library is being used with -- and
don't forget to include the version of the mpatrol library you are
using!  Nowadays I only use Windows XP and Interix or Cygwin on Intel
x86 computers, so I will be most likely unable to reproduce most of the
system-specific bugs on other platforms.  A bug report that comes with
an associated fix will be most welcome.

   Enhancement requests and source code containing enhancements should
also be sent to <graemeroy@users.sourceforge.net> or the mpatrol
discussion group at `http://groups.yahoo.com/group/mpatrol/'.  If you
are planning to implement an enhancement, let me know first in case I
am (or someone else is) working towards the same goal -- that way, work
won't be wasted.  If you wish to send me source code changes please
send the changes as context diffs or in an e-mail attachment as a
compressed tar archive.

* Menu:

* Generic notes::               Notes for all platforms.
* UNIX notes::                  Notes for UNIX platforms.
* Amiga notes::                 Notes for Amiga platforms.
* Windows notes::               Notes for Windows platforms.
* Netware notes::               Notes for Netware platforms.


File: mpatrol.info,  Node: Generic notes,  Next: UNIX notes,  Up: Notes

I.1 Notes for all platforms
===========================

   * Overriding the C++ operators to get source-level information using
     the preprocessor is still a bit dodgy and isn't likely to get much
     better, so `MP_NONEWDELETE' may have to be used a lot.  Explicit
     references to `operator new' rather than `new' are likely to
     result in compilation errors, and the way that source level
     information is obtained for `operator delete' means that the
     resulting code will not be thread-safe.  It might also be an idea
     to provide an allocation class from which user-defined memory
     allocators can be derived.

   * Need to add support for other 64-bit processors in addition to the
     existing Alpha and SPARC V9 support.  This shouldn't be too hard,
     but I haven't got access to such processors to test them, so I
     haven't been able to yet.  Also need to add support for building
     on targets and architectures where no operating system features
     are required or even available.

   * Need to improve the concurrency in the thread-safe version of the
     mpatrol library.  Currently, only one thread at a time is allowed
     to enter the mpatrol library, but it should be possible to extend
     this to protect individual data structures.  Note that this will
     not only help to improve efficiency, but might also allow the
     mpatrol library to uncover bugs in thread-safe code that are
     timing-dependent.

   * Need to make the library re-entrant.  This could be achieved by
     moving the static variables in `memory.c', `stack.c', `mutex.c',
     `diag.c', `trace.c', `option.c' and `sbrk.c' into the `infohead'
     structure and then having an array of `infohead' structures from
     which to allocate new memory headers when a new one is required.
     This is only necessary for Amiga shared libraries and Netware NLMs
     since UNIX and Windows platforms allocate a new copy of the data
     section in a shared library or DLL when it is opened by a new
     process.

   * Some implementations of call stack traversal are limited and will
     only likely work for unoptimised code.  A much better solution
     would be write the implementations at a lower level in assembly,
     but this is much less portable.  Perhaps there is a library which
     can be used to perform this across many operating systems and
     processor architectures, or maybe someone would like to write
     one(1)?  I can think of many applications that would benefit from
     such a library besides this one.

   * An alternative implementation for call stack traversal uses the
     functions `__builtin_frame_address()' and
     `__builtin_return_address()' that are available when the library
     is compiled with `gcc'.  However, they can only traverse a number
     of stack frames at compile-time, not run-time so there is a
     maximum number of stack frames that can be traversed at any one
     time.  The implementation depends on both of these builtin
     functions returning `NULL' when the top of stack is reached.  If
     this is not the case then this method cannot be used or should
     only be used with a small number of fixed stack frames.  However,
     using `backtrace()' from glibc is also supported as well.

   * Is it worth adding functions to manually push and pop entries on
     the call stack for platforms which have no support for call stack
     traversal?  This is currently not a high-priority issue since
     almost all of the platforms that mpatrol is available on have
     support for full call stack traversal.  However, it might be handy
     anyway as an additional debugging tool for entering and leaving
     scopes.

   * Need to change `__mp_compareaddrs()' so that it will improve the
     detection of when to free memory allocations made by `alloca()'
     and its related functions.  This will involve checking the common
     return addresses in the call stacks instead of just checking them
     if the stack depth is the same.  Also, on systems that don't have
     full call stack traversal, the minimum number of bytes that stack
     frames should differ by should be platform-dependent since the
     current value is way too high.

   * Perhaps hash the call stacks when they are stored internally by
     the routines in `addr.c'.  This would make for quick checks to see
     if two call stacks are identical and it might save some memory in
     the process.

   * There is an issue with callback functions if they call mpatrol
     library functions, since this may lead to recursion in some
     obscure cases.  Callback functions could also be defined for
     `__malloc_hook()', `__realloc_hook()' and `__free_hook()' in much
     the same way as for the GNU C library.

   * Need to store filename and line number information in all call
     stacks so that the information can be used at program termination.
     May also need to display this information in the
     `__mp_printinfo()' function and add this information to the
     profiling output file so that `mprof' can make use of it.

   * In object file formats that support nested symbols (such as ELF),
     the current implementation will tend to show some shortcomings.
     This is because there is currently no nesting count in the
     function that deals with symbol name lookup, so the wrong symbol
     name may be displayed in diagnostics.

   * In object file formats that don't store the sizes of symbols (such
     as basic `a.out', or when using the GNU BFD library), the current
     implementation will simply assume that the current symbol
     terminates at the beginning of the next symbol in the virtual
     address space.

   * Perhaps add an option to prevent symbols from being read from
     object files.  This might be necessary if mpatrol is used in a
     program that loads shared libraries explicitly, or if there is too
     much memory being used by mpatrol to store the symbol details.

   * Add functions to start and stop profiling, and perhaps also to
     clear the profiling tables and begin a new profiling output file.
     Should also write more information to the profiling output file,
     such as the date that it was produced on and the word size of the
     processor that it was produced on, so that `mprof' will not crash
     when reading a profiling output file produced on a processor that
     has a different word size.

   * Perhaps add the ability to profile memory operations such as
     `memcpy()' and `memset()' to the existing memory allocation
     profiling facility.  Also, add options to `mprof' to write out
     files that can be used by chart drawing software for a better
     visualisation of the first few profiling tables.

   * Perhaps the allocation call graph table should have the capability
     to be sorted in `mprof' and the `--leaks' option should work with
     it as well.  There should be better handling of cycles in the call
     graph and there is currently a problem in that `mprof' cannot
     distinguish between call sites with very low code addresses that
     have no symbols and that conflict with existing symbol indices.

   * Extend the `mptrace' command to graphically display the size of
     the heap plotted against time and the allocation size frequency.
     Also rewrite the GUI support to use GNOME instead of Motif,
     possibly also using GLADE.

   * Possibly add widgets to the `mptrace' window to pause and quit.
     Might also be handy to add the ability to write out charts
     summarising tracing information.

   * Handle marked memory allocations in the leak table, and also
     perhaps write out to the mpatrol log file when an allocation is
     marked so that the `mleak' command will work correctly.

   * Improve the speed of watch points by setting a range of allocation
     indices for which they will be used.  This may require a lot of
     code changes in `alloc.c'.

   * Add a software watch point facility that can be placed on ranges
     of addresses in the heap.  Then, if a heap operation touches the
     watch point, either the user can be notified or a callback
     function can be called.  The same could be done for local
     variables if the stack frame can be easily determined, which would
     also allow detecting if a read from or write to memory was
     performed just beyond the stack pointer.

   * Add a CRC checksum to memory blocks and use it to check that freed
     memory allocations have not been corrupted when the `NOFREE' and
     `PRESERVE' options are in use on platforms which have no memory
     protection.

   * Perhaps extend the `NOFREE' option to prevent the mpatrol library
     from reusing freed memory allocations unless it really needs to.
     This would mean that no freed allocations would be reused until
     there is no more free memory left and mpatrol would normally have
     to allocate more from the system.  It could then convert as many
     freed allocations to free memory as it needs to fulfil the
     allocation request, although it would probably still have to abide
     by the minimum number of freed allocations set by the `NOFREE'
     option.

   * Perhaps change the behaviour of the `NOFREE' option so that it
     doesn't prevent in-place reallocations if there is enough memory
     to perform them.  Then an option could be added to force
     reallocations to always allocate new memory so that the behaviour
     could also be used when the `NOFREE' option is not used.

   * Add an option to set up a timer that will automatically check the
     heap after a certain number of clock cycles have elapsed.  This
     could be useful in programs that have long periods of time where
     no dynamic memory allocation functions are called, but heap
     allocations are still manipulated.  In addition, checks could
     automatically be made upon receipt of special signals sent to the
     program by the user and information about the last successful
     verification of the heap could be used to narrow down problems.
     Perhaps even some statistics could be printed on receipt of a
     special signal as well.

   * Add a diagnostic number count to each warning and error reported
     in the log file.  This could then be used to implement a
     `DIAGSTOP' option which would stop the program running after a
     certain number of diagnostics have been displayed.

   * Add the ability to stop in a debugger when a memory allocation is
     made from a particular file and line number, and perhaps also trap
     when a particular address is allocated as part of a memory
     allocation.

   * Perhaps add time information to the details stored about each
     memory allocation.  This is probably not useful unless the system
     provides a high-resolution timer.

   * Add an option (perhaps `NOINTERNAL') to suppress the display of
     internal (recursive) memory allocations in the mpatrol log file
     and also prevent information about such allocations being written
     to the profiling output and tracing output files.  Perhaps this
     could be made the default so that they behave in the same way as
     marked allocations, in which case we might want an option which
     prevents internal and marked allocations being hidden.  This could
     also be extended to prevent memory leaks from being reported if
     the original allocations were made from a given set of functions.

   * Add a function to add a block of memory to the heap, possibly a
     memory-mapped file.  Also add a function that can shrink the heap
     if large areas of free memory exist.

   * Maybe show the contents of the `MPATROL_OPTIONS' environment
     variable in the summary as well.

   * Add versions of `mallopt()', `mallinfo()', `memorymap()',
     `mallocctl()', `mallocblksize()' and `msize()' which are provided
     in many other malloc libraries.  These won't necessarily behave in
     exactly the same way as existing implementations, but at least
     there won't be link errors when compiling source code which uses
     them.  Also, add support for setting as many remaining options in
     `__mp_setoption()' as possible and perhaps even some options
     before the mpatrol library has been initialised.

   * Add similar functions to the GNU `mcheck()' and `mprobe()'
     functions.  Perhaps also add an mpatrol tool to add compatibility
     with the GNU memusage tool.

   * Perhaps add debugging/tracing versions of the string manipulation
     functions, such as `strlen()' and `strcmp()' in much the same way
     as was done for the memory operation functions.  The only problem
     with this would be locale support, but perhaps it might be easier
     just to assume the C locale to begin with.  Also need to have
     better detection of internal and free blocks when displaying
     memory range errors.

   * Add wide-character equivalents of `memset()', etc.  These are
     defined as `wmemset()', etc. and are now part of ANSI C.  Also add
     `wcsdup()', `memdup()' and `xmemdup()' as well as `mempcpy()' and
     `memrchr()'.

   * Perhaps reimplement the standard I/O library for internal use by
     mpatrol, thus preventing recursive calls to `malloc()' each time a
     write to the log file occurs on some systems.  Example code to do
     this was submitted by Alexander Barton and this may well be
     incorporated into the library at some point in the future(2).

   * Add the ability to use the reporting and tracing infrastructure of
     mpatrol with the existing C library's memory allocation
     implementation.

   * The `LOG*' options could be extended to take a list of specific
     functions to log.  They could also only log operations spanning a
     range of addresses or allocation indices as well.

   * Add an option to limit the size of each memory allocation to a
     maximum number of bytes.  This could be useful if a memory
     allocation function is called with an uninitialised variable.

   * Add assertion macros to `mpatrol.h' that can be used in program
     code.  These could be used to assert that pointers have not been
     freed, are valid heap addresses or are strings, or perhaps even
     that the address is readable, writable and/or executable.  They
     would be disabled if `NDEBUG' is defined.

   * Add support functions that could be added to user code to enter
     and leave scopes in a source file and ensure that all allocations
     allocated within the scope are freed by the time the scope has
     been exited.

   * Add support for the `-finstrument-functions' option of the GNU
     compiler.  This would allow mpatrol to keep track of the entry to
     and exit from every function, but would only work for code
     compiled with this option.

   * Extend the Checker-support functions to store and check
     information about access permissions within heap memory and
     perhaps also in the stack as well, and also improve the
     diagnostics from the checker functions if they fail.  Currently,
     the Checker-support functions only ensure that no memory accesses
     cross allocation boundaries or access free memory.  Could also
     make use of the `etext', `edata' and `end' pointers that are set
     at run-time on most UNIX systems.  Need to properly implement
     `chkr_check_exec()'.

   * Details of the segments which make up the executable file and any
     shared libraries could be made use of in order to detect
     operations which cross such segments.  For example, a memory
     operation may erroneously cross the data and BSS segments.  The
     symbol table for data symbols could also be used to provide much
     finer-grained error-checking.  Need to make use of the
     `__mp_memquery()' function.

   * Add garbage detection support to mpatrol.  This would be
     implemented as a function that would traverse all of the roots of
     the memory in a process and look for pointers into free memory or
     the lack of any pointers into allocated memory (to detect memory
     leaks).

   * Add an option to specify that all failed memory allocations should
     abort (or at least give a warning) instead of returning a `NULL'
     pointer.  Also, perhaps add an option to display the partial
     contents of freed and unfreed allocations in the mpatrol log file.

   * Perhaps add memory protection to the simulated `sbrk' heap.

   * Add an option to force the mpatrol library to return `NULL' if it
     is asked to allocate a zero-sized block of memory.  This might be
     useful for SVID compliant programs.  Perhaps also extend the
     mpatrol library to allow zero-sized blocks.  I suspect the easiest
     way to do this is to have a special address that is always
     returned for such blocks and that will have the appropriate size
     of overflow buffers depending on the options used.

   * Add an option to report if one thread resizes or frees another
     thread's allocations.  This may not be useful in most cases, but
     it might be possible to track down some obscure bugs in some
     situations.

   * Perhaps add internationalisation support through the use of
     locales and message catalogs.  Unfortunately, there does not
     appear to be a unified method for doing this across all platforms
     and there may also be issues with third-party libraries calling
     `malloc()' and other related routines when the mpatrol library is
     attempting to initialise itself.

   * There is currently a problem when the mpatrol library encounters
     an illegal memory access on UNIX and Windows platforms, and there
     is a further illegal memory access when it is displaying the
     summary.  This should be prevented by disabling the signal handler
     at its first entry.

   * Need to make the mpalloc library threadsafe(3).  This is only
     likely to be an issue when calling `MP_FAILURE()'.  Should also
     add something similar to `xmalloc_set_program_name()' in order to
     show the program name when a memory allocation fails.  If the C++
     operators fail to allocate memory in libmpalloc then there should
     probably also be an exception thrown to mimic the behaviour of
     libmpatrol, although this isn't a big issue since the program
     should be completely recompiled to remove mpatrol debugging before
     a release.  In the same vein, perhaps there should be some sort of
     support for `set_new_handler()' in libmpalloc.

   * Add an option to write the mpatrol log file in HTML format, or
     even better XML format.  Need to also extend what is written out
     by the `--hatf-file' option.

   * The `mpsym' command could optionally preserve any stack traceback
     lines that already have symbolic or debugging information
     associated with them.  It could also support more debuggers other
     than just `gdb'.  Finally, it could support `-' as the filename
     for reading the mpatrol log file from the standard input file
     stream.

   * A good idea might be to have the `mpatrol' command read options
     from a configuration file instead of an environment variable, but
     that will only work if it doesn't involve allocating any memory
     before the mpatrol library has been initialised.

   * Perhaps incorporate a C++ encoded name demangler into the mpatrol
     library.  The most likely candidate is the GNU demangler that
     comes with the libiberty library, but that currently allocates
     temporary space on the heap using `xmalloc()' which means that it
     will run unbearably slowly under mpatrol(4).

   * Add a script to wrap around various popular C and C++ compiler
     drivers so that linking with the mpatrol library is much less
     laborious.  In addition, a user-defined command or script file
     could be executed at the end of every invocation of the `mpatrol'
     command.

   * Add a script to automatically run the mpatrol library tests.  It
     could be quite hard to verify the tests since the heap addresses
     are likely to be different on every new build and will certainly
     be different across different platforms.

   * Improve the autoconf, automake and libtool support.  Also update
     the `mupdate' shell script to automatically update the version
     numbers contained in the files in the `pkg' directory.

   * The postscript version of the quick reference card seems to print
     at an unusual offset on some printers.

   * Perhaps add benchmark tests for dynamic memory allocation
     functions and memory operation functions.  Obviously the mpatrol
     library would perform much worse than normal malloc libraries, but
     it would help to see just how much worse so that speed
     improvements could be made.

   * Add support for the BeOS operating system, as well as MacOS, NeXT
     and OS/2.  Perhaps MS-DOS might be possible as well.

   ---------- Footnotes ----------

   (1) There is now a library called libunwind that mpatrol can be
built with to add support for stack traversal on various architectures
and more will likely follow in the future.  There is also a library
called StackTrace written by Bjorn Reese which invokes a debugger to
generate a stack traceback on certain UNIX platforms, although this
method would be too slow for mpatrol to use.

   (2) This code can be applied as an mpatrol library patch which can
be downloaded from
`http://heanet.dl.sourceforge.net/sourceforge/mpatrol/mpatrol_patch1.tar.gz'.

   (3) And perhaps also make the mptools library threadsafe as well

   (4) If you really really want this functionality then code to do
this is available as an mpatrol library patch which can be downloaded
from
`http://heanet.dl.sourceforge.net/sourceforge/mpatrol/mpatrol_patch4.tar.gz'.


File: mpatrol.info,  Node: UNIX notes,  Next: Amiga notes,  Prev: Generic notes,  Up: Notes

I.2 Notes for UNIX platforms
============================

   * Need to improve watch point facility in order to speed it up by an
     order of magnitudes.  This will most likely involve removing all
     watch points when entering the library and replacing them when
     returning to user code.

   * Improve use of watch points by allowing an option which will only
     install write watch points instead of both read and write watch
     points.  Not only will this speed up the use of watch points, but
     will also cause less problems with reading from misaligned memory
     allocations.

   * There seems to be a problem on some UNIX systems in that the
     `mprotect()' call will not work unless it is used on memory that
     has been allocated with `mmap()'.  This needs to be investigated
     further.

   * Install a signal handler that can be sent a non-terminating signal
     that would instruct the mpatrol library to log a list of memory
     leaks and possibly write a profile output file.  This would be
     useful for monitoring daemon processes.

   * There is currently a problem in that the call stack displayed from
     within the illegal memory access signal handler is not necessarily
     accurate with respect to the function at the top of the stack.  In
     addition, signal handlers shouldn't technically call I/O functions
     in case of additional signals being caught so this may need to be
     improved.

   * Need to add a way of initialising the thread-safe version of the
     library when it is not compiled on a system that supports `.init'
     sections, or if it is not compiled with the GNU C compiler, or if
     it is not compiled with a C++ compiler.  Also perhaps need to
     support other threads packages instead of just POSIX threads.

   * Need to add support for call stack traversal for the Itanium
     processor architecture.  The current implementation of call stack
     traversal for the Motorola 88xx0 family is also a bit flaky and so
     should only be used when the library and program are built
     unoptimised.  This could be improved on DG/UX platforms by making
     use of the TDESC information stored in the object files.

   * Need to add support for obtaining the program name from the stack
     for the Alpha, Itanium and Motorola 88xx0 processor architectures.
     If there is no support for determining the filename that a program
     was invoked with then the `PROGFILE' option can be used to specify
     the program name at run-time.

   * If the `MP_LIBRARYSTACK_SUPPORT' preprocessor macro is defined when
     building the mpatrol library on IRIX platforms then the `libexc'
     library must also be linked in.  However, execution speed will
     fall dramatically since the `unwind()' function within that
     library calls `malloc()', `free()' and other memory operation
     functions every time it is invoked.  The only reason to use this
     library rather than the default method of stack traversal on MIPS
     would be if that method failed due to a bug (in which case it
     should be reported anyway).

   * The mpatrol library `unwind()' function on MIPS platforms may have
     problems with call stack traversal in alternative stacks, such as
     those used by signal handlers.  The call stack will then terminate
     at the point at which the handler was called rather than unwinding
     to the top of the stack.

   * The library cannot currently read any symbols from shared objects
     that have been read via `dlopen()', `shl_load()' or similar
     functions(1).  In addition, symbols cannot currently be read from
     any COFF or XCOFF shared libraries on LynxOS and some work needs
     to be done to build the mpatrol library as a shared library on
     LynxOS.

   * Perhaps add support for reading HP/UX executable files and
     libraries in the SOM object file format without needing to use the
     GNU BFD library.

   * Perhaps add support for other popular text editors in the `mpedit'
     command.  Also add a way to specify editor options to the `mpedit'
     command.

   * Add support for SCO UNIX, Ultrix and other non-System V UNIX
     operating systems.  Also test on NetBSD, OpenBSD and SunOS as
     support has been written for these systems but is untested.  The
     SunOS port requires an ANSI C compiler, though.

   * The `--dynamic' option to the `mpatrol' command does not always
     work on systems whose dynamic linkers support the `LD_PRELOAD' or
     `_RLD_LIST' environment variables.  This is because the object
     file format access libraries do not exist in shared form on such
     systems.

   * Perhaps add files to build the mpatrol library and tools as BSD
     packages.

   ---------- Footnotes ----------

   (1) There is an mpatrol library patch that supports reading symbols
from shared libraries opened by `dlopen()' which can be downloaded from
`http://heanet.dl.sourceforge.net/sourceforge/mpatrol/mpatrol_patch2.tar.gz'.


File: mpatrol.info,  Node: Amiga notes,  Next: Windows notes,  Prev: UNIX notes,  Up: Notes

I.3 Notes for Amiga platforms
=============================

The Amiga has now been re-released as a completely new machine which
comes with a completely new operating system.  As a result, I will not
be implementing any of the following features (or fixing any of the
following problems) in mpatrol for the old AmigaOS.  Support for the
new AmigaOS may be added in the future.

   * Perhaps add support for building mpatrol as an Amiga shared
     library.  I attempted to do this in a previous release of mpatrol,
     but it would have involved too many source changes to get working
     fully.  Perhaps it's not even worth implementing as the archive
     library works fine.  However, if it is built as a shared library
     and `malloc()' and related functions are dynamically linked in
     some executable files then perhaps it would be possible to override
     these functions, thus getting the `--dynamic' option in the
     `mpatrol' command to work.

   * Need to fix the problem where the maximum guaranteed alignment of
     an internal mpatrol library memory allocation is 8 bytes.
     However, this limitation does not affect the `memalign()' and
     related functions, and should not have any effect on the running
     of mpatrol since no datatypes require an alignment of more than 8
     bytes.

   * Need to add proper support for call stack traversal for both the
     Motorola 680x0 and PowerPC processor architectures.  When `gcc' is
     being used then up to two stack frames can be traversed, but this
     should really be extended without requiring
     `MP_BUILTINSTACK_SUPPORT'.  When SAS/C is being used then there is
     no support for call stack traversal.

   * Need to add proper support for reading symbols from Amiga
     executable files.  When `gcc' is being used then the BFD library
     routines will be called to determine the symbols from the
     executable file, but this will only work for objects compiled with
     `gcc' and there currently appears to be a problem getting the
     `USEDEBUG' option to work.  When SAS/C is being used then there is
     no support for reading symbols from executable files.  Also need
     to add support for reading symbols from any shared libraries that
     are required by the program.

   * Possibly make use of other software such as Enforcer, Mungwall or
     MuLib in order to provide some form of memory protection.  The
     features of SegTracker could also be put to good use so that the
     file and hunk location of entries on the call stack could be
     determined.

   * Could add support for the `EDIT' and `LIST' options.  This would
     probably involve finding a way to invoke a shell script without
     having to search for the script file or allocating memory in the
     process.

   * Add GUI support for the `mptrace' command.

   * When using SAS/C it is currently not possible to override the
     definition of `malloc()', etc., without including the `mpatrol.h'
     header file first.  This is because the compiler startup code and
     libraries call `malloc()' before everything is set up, and so the
     library cannot properly initialise itself if the `malloc()' that
     the startup code finds is the `malloc()' in the mpatrol library.
     This restriction does not exist when using `gcc'.

   * Add support for the Amiga in the threads test in
     `tests/pass/test5.c'.  The Amiga doesn't really have support for
     threads but its processes are similar enough to threads.

   * Perhaps add an `Installer' installation script with icons.


File: mpatrol.info,  Node: Windows notes,  Next: Netware notes,  Prev: Amiga notes,  Up: Notes

I.4 Notes for Windows platforms
===============================

   * Need to add support for processors other than the Intel 80x86.
     However, about 99% of Windows platforms run on this processor
     family -- does anyone really use Windows with other processors?
     Also finish MinGW support for building with the GNU C compiler but
     using the Microsoft C library, and also Cygwin support, although
     this is effectively mpatrol built with `-DTARGET=TARGET_UNIX' on
     Windows platforms.

   * Perhaps add support for compiling the mpatrol library with `gcc' on
     Windows platforms so that the GNU BFD library can be used as well.

   * There seems to be a problem when mixing the archive version of the
     mpatrol library and the Microsoft C run-time library DLL, and vice
     versa.  This needs to be looked into, but for the moment, don't
     mix them.

   * The library cannot currently read any symbols from DLLs that have
     been read via `LoadLibrary()'.

   * There seems to be a disparity between different versions of the
     imagehlp library.  It would appear that the latest incarnation of
     the imagehlp library has had some functions removed and placed in
     a new library called debughlp.  Perhaps this simply means that
     `debughlp.lib' needs to be linked in as well, but maybe there's
     more to it than that.

   * Perhaps add support for the `mpatrol' command's `--dynamic' option
     by preloading the mpatrol DLL from the `mpatrol' command.

   * Could add support for the `EDIT' and `LIST' options.  This would
     probably involve finding a way to invoke a batch file without
     having to search for the batch file or allocating memory in the
     process.

   * Add GUI support for the `mptrace' command.

   * Add a Windows resource file to the mpatrol library with copyright
     and version information.

   * Perhaps add an `InstallShield' installation script with icons.

